{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/Interfaces/IDepositLimitModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IDepositLimitModule {\n    function availableDepositLimit(address receiver) external view returns (uint256);\n}"
    },
    "contracts/Interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    // solhint-disable ordering\n    // solhint-disable max-line-length\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 assets);\n}"
    },
    "contracts/Interfaces/ISharesManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"../VaultStructs.sol\";\nimport {IERC4626} from \"./IERC4626.sol\";\n\ninterface ISharesManager is IERC4626 {\n    // solhint-disable max-line-length\n    // solhint-disable ordering\n\n    function balanceOf(address addr) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function spendAllowance(address owner, address spender, uint256 amount) external;\n    function transfer(address sender, address receiver, uint256 amount) external;\n    function transferFrom(address sender, address receiver, uint256 amount) external returns (bool);\n    function approve(address owner, address spender, uint256 amount) external returns (bool);\n    function increaseAllowance(address owner, address spender, uint256 amount) external returns (bool);\n    function decreaseAllowance(address owner, address spender, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n    function burnShares(uint256 shares, address owner) external;\n    function unlockedShares() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function burnUnlockedShares() external;\n    function totalAssets() external view returns (uint256);\n    function convertToAssets(uint256 shares, Rounding rounding) external view returns (uint256);\n    function convertToShares(uint256 assets, Rounding rounding) external view returns (uint256);\n    function erc20SafeApprove(address token, address spender, uint256 amount) external;\n    function erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) external;\n    function erc20SafeTransfer(address token, address receiver, uint256 amount) external;\n    function issueShares(uint256 shares, address recipient) external;\n    function issueSharesForAmount(uint256 amount, address recipient) external returns (uint256);\n    function maxDeposit(address receiver) external view returns (uint256);\n    function maxWithdraw(address owner, uint256 _maxLoss, address[] memory _strategies) external returns (uint256);\n    function deposit(address sender, address recipient, uint256 assets) external returns (uint256);\n    function mint(address sender, address recipient, uint256 shares) external returns (uint256);\n    function assessShareOfUnrealisedLosses(address strategy, uint256 assetsNeeded) external view returns (uint256);\n    function withdrawFromStrategy(address strategy, uint256 assetsToWithdraw) external;\n    function calculateShareManagement(uint256 loss, uint256 totalFees, uint256 protocolFees) external returns (ShareManagement memory shareManagement);\n    function handleShareBurnsAndIssues(ShareManagement memory shares, FeeAssessment memory fees, uint256 gain, uint256 loss, address strategy) external returns (uint256 , uint256);\n    function manageUnlockingOfShares(uint256 previouslyLockedShares, uint256 newlyLockedShares) external;\n    function setDepositLimit(uint256 _depositLimit) external;\n}"
    },
    "contracts/Interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IStrategy {\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);\n    function deposit(uint256 assets, address receiver) external returns (uint256);\n    function asset() external view returns (address);\n    function balanceOf(address owner) external view returns (uint256);\n    function maxDeposit(address receiver) external view returns (uint256);\n    function totalAssets() external view returns (uint256);\n    function convertToAssets(uint256 shares) external view returns (uint256);\n    function convertToShares(uint256 assets) external view returns (uint256);\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n    function maxRedeem(address owner) external view returns (uint256);\n}"
    },
    "contracts/Interfaces/IVaultEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL 3.0\n// Copyright Fathom 2023\n\npragma solidity ^0.8.16;\n\nimport \"../VaultStructs.sol\";\n\ninterface IVaultEvents {\n    // STRATEGY EVENTS\n    event StrategyChanged(address indexed strategy, StrategyChangeType changeType);\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 currentDebt,\n        uint256 protocolFees,\n        uint256 totalFees,\n        uint256 totalRefunds\n    );\n    // DEBT MANAGEMENT EVENTS\n    event DebtUpdated(\n        address indexed strategy,\n        uint256 currentDebt,\n        uint256 newDebt\n    );\n    // ROLE UPDATES\n    event RoleSet(address indexed account, bytes32 role);\n    event RoleStatusChanged(bytes32 indexed role, RoleStatusChange indexed status);\n    event UpdateRoleManager(address indexed roleManager);\n\n    event UpdateAccountant(address indexed accountant);\n    event UpdateDefaultQueue(address[] newDefaultQueue);\n    event UpdateUseDefaultQueue(bool useDefaultQueue);\n    event UpdatedMaxDebtForStrategy(\n        address indexed sender,\n        address indexed strategy,\n        uint256 newDebt\n    );\n    event UpdateDepositLimit(uint256 depositLimit);\n    event UpdateMinimumTotalIdle(uint256 minimumTotalIdle);\n    event UpdateProfitMaxUnlockTime(uint256 profitMaxUnlockTime);\n    event DebtPurchased(address indexed strategy, uint256 amount);\n    event Shutdown();\n\n    // STORAGE MANAGEMENT EVENTS\n    event UpdateDepositLimitModule(address indexed depositLimitModule);\n    event UpdateWithdrawLimitModule(address indexed withdrawLimitModule);\n}"
    },
    "contracts/Interfaces/IWithdrawLimitModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IWithdrawLimitModule {\n    function availableWithdrawLimit(address owner, uint256 maxLoss, address[] calldata strategies) external returns (uint256);\n}"
    },
    "contracts/SharesManager.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./VaultStorage.sol\";\nimport \"./Interfaces/IVaultEvents.sol\";\nimport \"./Interfaces/ISharesManager.sol\";\nimport \"./Interfaces/IStrategy.sol\";\nimport \"./Interfaces/IDepositLimitModule.sol\";\nimport \"./Interfaces/IWithdrawLimitModule.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n@title STRATEGY MANAGEMENT\n*/\n\ncontract SharesManager is VaultStorage, IVaultEvents, ReentrancyGuard, ISharesManager {\n    // solhint-disable not-rely-on-time\n    // solhint-disable var-name-mixedcase\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    // solhint-disable max-line-length\n    // solhint-disable ordering\n\n    using Math for uint256;\n\n    // IMMUTABLE\n    // Address of the underlying token used by the vault\n    IERC20 public immutable ASSET;\n    uint8 public immutable DECIMALS;\n\n    // ERC20 - name of the vault's token\n    string public override name;\n    // ERC20 - symbol of the vault's token\n    string public override symbol;\n\n    error ERC20InsufficientAllowance();\n    error InsufficientFunds();\n    error ZeroAddress();\n    error ERC20PermitExpired();\n    error ERC20PermitInvalidSignature();\n    error InsufficientShares();\n    error InactiveStrategy();\n    error StrategyIsShutdown();\n    error ExceedDepositLimit();\n    error ZeroValue();\n    error StrategyDebtIsLessThanAssetsNeeded();\n    error MaxLoss();\n    error InsufficientAssets();\n    error TooMuchLoss();\n    error InvalidAssetDecimals();\n    error UsingModule();\n\n    constructor(\n        address _asset,\n        uint8 _decimals,\n        string memory _name,\n        string memory _symbol\n    ) {\n        DECIMALS = _decimals;\n        if (DECIMALS >= 256) {\n            revert InvalidAssetDecimals();\n        }\n        ASSET = IERC20(_asset);\n        name = _name;\n        symbol = _symbol;\n    }\n\n\n    // SHARE MANAGEMENT\n    // ERC20\n\n    // @notice Get the balance of a user.\n    // @param addr The address to get the balance of.\n    // @return The balance of the user.\n    function balanceOf(address addr) external view override returns (uint256) {\n        if(addr == address(this)) {\n            return _balanceOf[addr] - _unlockedShares();\n        }\n        return _balanceOf[addr];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal {\n        // Unlimited approval does nothing (saves an SSTORE)\n        uint256 currentAllowance = _allowance[owner][spender];\n        if (currentAllowance < amount) {\n            revert ERC20InsufficientAllowance();\n        }\n        _approve(owner, spender, currentAllowance - amount);\n    }\n\n    function spendAllowance(address owner, address spender, uint256 amount) external override {\n        _spendAllowance(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address receiver, uint256 amount) internal {\n        uint256 currentBalance = _balanceOf[sender];\n        if (currentBalance < amount) {\n            revert InsufficientFunds();\n        }\n        if (sender == address(0) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _balanceOf[sender] = currentBalance - amount;\n        uint256 receiverBalance = _balanceOf[receiver];\n        _balanceOf[receiver] = receiverBalance + amount;\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function transfer(address sender, address receiver, uint256 amount) external override {\n        _transfer(sender, receiver, amount);\n    }\n\n    function transferFrom(address sender, address receiver, uint256 amount) external override returns (bool) {\n        _spendAllowance(sender, msg.sender, amount);\n        _transfer(sender, receiver, amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal returns (bool) {\n        if (owner == address(0) || spender == address(0)) {\n            revert ZeroAddress();\n        }\n        _allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n        return true;\n    }\n\n    function approve(address owner, address spender, uint256 amount) external override returns (bool) {\n        return _approve(owner, spender, amount);\n    }\n\n    function _increaseAllowance(address owner, address spender, uint256 amount) internal returns (bool) {\n        uint256 newAllowance = _allowance[owner][spender] + amount;\n        _approve(owner, spender, newAllowance);\n        return true;\n    }\n\n    function increaseAllowance(address owner, address spender, uint256 amount) external override returns (bool) {\n        return _increaseAllowance(owner, spender, amount);\n    }\n\n    function decreaseAllowance(address owner, address spender, uint256 amount) external override returns (bool) {\n        uint256 newAllowance = _allowance[owner][spender] - amount;\n        _approve(owner, spender, newAllowance);\n        return true;\n    }\n\n    function permit(\n        address owner, \n        address spender, \n        uint256 amount, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) external override returns (bool) {\n        if (owner == address(0)) {\n            revert ZeroAddress();\n        }\n        if (deadline < block.timestamp) {\n            revert ERC20PermitExpired();\n        }\n        uint256 nonce = nonces[owner];\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPE_HASH, owner, spender, amount, nonce, deadline));\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                structHash\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        if (recoveredAddress == address(0) || recoveredAddress != owner) {\n            revert ERC20PermitInvalidSignature();\n        }\n        \n        // Set the allowance to the specified amount\n        _approve(owner, spender, amount);\n\n        // Increase nonce for the owner\n        nonces[owner]++;\n\n        emit Approval(owner, spender, amount);\n        return true;\n    }\n\n    function _burnShares(uint256 shares, address owner) internal {\n        if (_balanceOf[owner] < shares) {\n            revert InsufficientShares();\n        }\n        _balanceOf[owner] -= shares;\n        totalSupplyAmount -= shares;\n        emit Transfer(owner, address(0), shares);\n    }\n\n    function burnShares(uint256 shares, address owner) external override {\n        _burnShares(shares, owner);\n    }\n\n    // Returns the amount of shares that have been unlocked.\n    // To avoid sudden pricePerShare spikes, profits must be processed \n    // through an unlocking period. The mechanism involves shares to be \n    // minted to the vault which are unlocked gradually over time. Shares \n    // that have been locked are gradually unlocked over profitMaxUnlockTime.\n    function _unlockedShares() internal view returns (uint256) {\n        uint256 _fullProfitUnlockDate = fullProfitUnlockDate;\n        uint256 currUnlockedShares = 0;\n        if (_fullProfitUnlockDate > block.timestamp) {\n            // If we have not fully unlocked, we need to calculate how much has been.\n            currUnlockedShares = profitUnlockingRate * (block.timestamp - lastProfitUpdate) / MAX_BPS_EXTENDED;\n        } else if (_fullProfitUnlockDate != 0) {\n            // All shares have been unlocked\n            currUnlockedShares = _balanceOf[address(this)];\n        }\n        return currUnlockedShares;\n    }\n\n    function unlockedShares() external override view returns (uint256) {\n        return _unlockedShares();\n    }\n\n    // Need to account for the shares issued to the vault that have unlocked.\n    function _totalSupply() internal view returns (uint256) {\n        return totalSupplyAmount - _unlockedShares();\n    }\n\n    function totalSupply() external override view returns (uint256) {\n        return _totalSupply();\n    }\n\n    // Burns shares that have been unlocked since last update. \n    // In case the full unlocking period has passed, it stops the unlocking.\n    function burnUnlockedShares() external override {\n        // Get the amount of shares that have unlocked\n        uint256 currUnlockedShares = _unlockedShares();\n        // IF 0 there's nothing to do.\n        if (currUnlockedShares == 0) return;\n        \n        // Only do an SSTORE if necessary\n        if (fullProfitUnlockDate > block.timestamp) {\n            lastProfitUpdate = block.timestamp;\n        }\n        \n        // Burn the shares unlocked.\n        _burnShares(currUnlockedShares, address(this));\n    }\n\n    // Total amount of assets that are in the vault and in the strategies.\n    function _totalAssets() internal view returns (uint256) {\n        return totalIdleAmount + totalDebtAmount;\n    }\n\n    function totalAssets() external override view returns (uint256) {\n        return _totalAssets();\n    }\n\n    // assets = shares * (total_assets / total_supply) --- (== price_per_share * shares)\n    function _convertToAssets(uint256 shares, Rounding rounding) internal view returns (uint256) {\n        if (shares == type(uint256).max || shares == 0) {\n            return shares;\n        }\n\n        uint256 currentTotalSupply = _totalSupply();\n        // if total_supply is 0, price_per_share is 1\n        if (currentTotalSupply == 0) {\n            return shares;\n        }\n\n        uint256 numerator = shares * _totalAssets();\n        uint256 amount = numerator / currentTotalSupply;\n        if (rounding == Rounding.ROUND_UP && numerator % currentTotalSupply != 0) {\n            amount += 1;\n        }\n\n        return amount;\n    }\n\n    function convertToAssets(uint256 shares, Rounding rounding) external override view returns (uint256) {\n        return _convertToAssets(shares, rounding);\n    }\n\n    // shares = amount * (total_supply / total_assets) --- (== amount / price_per_share)\n    function _convertToShares(uint256 assets, Rounding rounding) internal view returns (uint256) {\n        if (assets == type(uint256).max || assets == 0) {\n            return assets;\n        }\n\n        uint256 currentTotalSupply = _totalSupply();\n        uint256 currentTotalAssets = _totalAssets();\n        \n        if (currentTotalAssets == 0) {\n            // if total_assets and total_supply is 0, price_per_share is 1\n            if (currentTotalSupply == 0) {\n                return assets;\n            } else {\n                // Else if total_supply > 0 price_per_share is 0\n                return 0;\n            }\n        }\n\n        uint256 numerator = assets * currentTotalSupply;\n        uint256 shares = numerator / currentTotalAssets;\n        if (rounding == Rounding.ROUND_UP && numerator % currentTotalAssets != 0) {\n            shares += 1;\n        }\n\n        return shares;\n    }\n\n    function convertToShares(uint256 assets, Rounding rounding) external override view returns (uint256) {\n        return _convertToShares(assets, rounding);\n    }\n\n    // Used only to approve tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function erc20SafeApprove(address token, address spender, uint256 amount) external override {\n        if (token == address(0) || spender == address(0)) {\n            revert ZeroAddress();\n        }\n        require(IERC20(token).approve(spender, amount), \"approval failed\");\n    }\n\n    // Used only to transfer tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function _erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) internal {\n        if (token == address(0) || sender == address(0) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        require(IERC20(token).transferFrom(sender, receiver, amount), \"transfer failed\");\n    }\n\n    function erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) external override {\n        _erc20SafeTransferFrom(token, sender, receiver, amount);\n    }\n\n    // Used only to send tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function _erc20SafeTransfer(address token, address receiver, uint256 amount) internal {\n        if (token == address(0) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        require(IERC20(token).transfer(receiver, amount), \"transfer failed\");\n    }\n\n    function erc20SafeTransfer(address token, address receiver, uint256 amount) external override {\n        _erc20SafeTransfer(token, receiver, amount);\n    }\n\n    function _issueShares(uint256 shares, address recipient) internal {\n        if (recipient == address(0)) {\n            revert ZeroAddress();\n        }\n        _balanceOf[recipient] += shares;\n        totalSupplyAmount += shares;\n        emit Transfer(address(0), recipient, shares);\n    }\n\n    function issueShares(uint256 shares, address recipient) external override {\n        _issueShares(shares, recipient);\n    }\n\n    // Issues shares that are worth 'amount' in the underlying token (asset).\n    // WARNING: this takes into account that any new assets have been summed \n    // to total_assets (otherwise pps will go down).\n    function _issueSharesForAmount(uint256 amount, address recipient) internal returns (uint256) {\n        if (recipient == address(0)) {\n            revert ZeroAddress();\n        }\n        uint256 currentTotalSupply = _totalSupply();\n        uint256 currentTotalAssets = _totalAssets();\n        uint256 newShares = 0;\n\n        // If no supply PPS = 1.\n        if (currentTotalSupply == 0) {\n            newShares = amount;\n        } else if (currentTotalAssets > amount) {\n            newShares = amount * currentTotalSupply / (currentTotalAssets - amount);\n        } else {\n            // If total_supply > 0 but amount = totalAssets we want to revert because\n            // after first deposit, getting here would mean that the rest of the shares\n            // would be diluted to a price_per_share of 0. Issuing shares would then mean\n            // either the new depositor or the previous depositors will loose money.\n            revert(\"amount too high\");\n        }\n\n        // We don't make the function revert\n        if (newShares == 0) {\n            return 0;\n        }\n\n        _issueShares(newShares, recipient);\n        return newShares;\n    }\n\n    function issueSharesForAmount(uint256 amount, address recipient) external override returns (uint256) {\n        return _issueSharesForAmount(amount, recipient);\n    }\n\n    // ERC4626\n\n    function _maxDeposit(address receiver) internal view returns (uint256) {\n        if (receiver == address(this) || receiver == address(0)) {\n            return 0;\n        }\n\n        // If there is a deposit limit module set use that.\n        address currentDepositLimitModule = depositLimitModule;\n        if (currentDepositLimitModule != address(0)) {\n            // Use the deposit limit module logic\n            return IDepositLimitModule(currentDepositLimitModule).availableDepositLimit(receiver);\n        }\n\n        // Else use the standard flow.\n        uint256 currentTotalAssets = _totalAssets();\n        uint256 currentDepositLimit = depositLimit;\n        if (currentTotalAssets >= currentDepositLimit) {\n            return 0;\n        }\n\n        return currentDepositLimit - currentTotalAssets;\n    }\n\n    function maxDeposit(address receiver) external override view returns (uint256) {\n        return _maxDeposit(receiver);\n    }\n\n    // @notice Preview the amount of shares that would be minted for a deposit.\n    // @param assets The amount of assets to deposit.\n    // @return The amount of shares that would be minted.\n    function previewDeposit(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_DOWN);\n    }\n\n    // @dev Returns the max amount of `asset` an `owner` can withdraw.\n    // This will do a full simulation of the withdraw in order to determine\n    // how much is currently liquid and if the `max_loss` would allow for the \n    // tx to not revert.\n    // This will track any expected loss to check if the tx will revert, but\n    // not account for it in the amount returned since it is unrealised and \n    // therefore will not be accounted for in the conversion rates.\n    // i.e. If we have 100 debt and 10 of unrealised loss, the max we can get\n    // out is 90, but a user of the vault will need to call withdraw with 100\n    // in order to get the full 90 out.\n    function _maxWithdraw(address owner, uint256 _maxLoss, address[] memory _strategies)\n        internal\n        returns (uint256)\n    {\n        // Get the max amount for the owner if fully liquid.\n        uint256 maxAssets = _convertToAssets(_balanceOf[owner], Rounding.ROUND_DOWN);\n\n        // If there is a withdraw limit module use that.\n        if (withdrawLimitModule != address(0)) {\n            uint256 moduleLimit = IWithdrawLimitModule(withdrawLimitModule).availableWithdrawLimit(owner, _maxLoss, _strategies);\n            if (moduleLimit < maxAssets) {\n                maxAssets = moduleLimit;\n            }\n            return maxAssets;\n        }\n\n        // See if we have enough idle to service the withdraw.\n        uint256 currentIdle = totalIdleAmount;\n        if (maxAssets > currentIdle) {\n            // Track how much we can pull.\n            uint256 have = currentIdle;\n            uint256 loss = 0;\n            \n            // Cache the default queue.\n            // If a custom queue was passed, and we don't force the default queue.\n            // Use the custom queue.\n            address[] memory currentStrategies = _strategies.length != 0 && !useDefaultQueue ? _strategies : defaultQueue;\n\n            for (uint256 i = 0; i < currentStrategies.length; i++) {\n                address strategy = currentStrategies[i];\n                // Can't use an invalid strategy.\n                if (strategies[strategy].activation == 0) {\n                    revert InactiveStrategy();\n                }\n\n                // Get the maximum amount the vault would withdraw from the strategy.\n                uint256 toWithdraw = Math.min(\n                    maxAssets - have, // What we still need for the full withdraw\n                    strategies[strategy].currentDebt // The current debt the strategy has.\n                    );\n\n                // Get any unrealised loss for the strategy.\n                uint256 unrealisedLoss = _assessShareOfUnrealisedLosses(strategy, toWithdraw);\n\n                // See if any limit is enforced by the strategy.\n                uint256 strategyLimit = IStrategy(strategy).convertToAssets(\n                    IStrategy(strategy).maxRedeem(address(this))\n                );\n\n                // Adjust accordingly if there is a max withdraw limit.\n                if (strategyLimit < toWithdraw - unrealisedLoss) {\n                    // lower unrealised loss to the proportional to the limit.\n                    unrealisedLoss = (unrealisedLoss * strategyLimit) / toWithdraw;\n                    // Still count the unrealised loss as withdrawable.\n                    toWithdraw = strategyLimit + unrealisedLoss;\n                }\n\n                // If 0 move on to the next strategy.\n                if (toWithdraw == 0) {\n                    continue;\n                }\n\n                // If there would be a loss with a non-maximum `max_loss` value.\n                if (unrealisedLoss > 0 && _maxLoss < MAX_BPS) {\n                    // Check if the loss is greater than the allowed range.\n                    if (loss + unrealisedLoss > (have + toWithdraw) * _maxLoss / MAX_BPS) {\n                        // If so use the amounts up till now.\n                        break;\n                    }\n                }\n\n                // Add to what we can pull.\n                have += toWithdraw;\n\n                // If we have all we need break.\n                if (have >= maxAssets) {\n                    break;\n                }\n\n                // Add any unrealised loss to the total\n                loss += unrealisedLoss;\n            }\n\n            // Update the max after going through the queue.\n            // In case we broke early or exhausted the queue.\n            maxAssets = have;\n        }\n\n        return maxAssets;\n    }\n\n    function maxWithdraw(address owner, uint256 _maxLoss, address[] memory _strategies)\n        external\n        override\n        returns (uint256)\n    {\n        return _maxWithdraw(owner, _maxLoss, _strategies);\n    }\n\n    // @notice Preview the amount of shares that would be redeemed for a withdraw.\n    // @param assets The amount of assets to withdraw.\n    // @return The amount of shares that would be redeemed.\n    function previewWithdraw(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_UP);\n    }\n\n    // @notice Withdraw an amount of asset to `receiver` burning `owner`s shares.\n    // @dev The default behavior is to not allow any loss.\n    // @param assets The amount of asset to withdraw.\n    // @param receiver The address to receive the assets.\n    // @param owner The address who's shares are being burnt.\n    // @param max_loss Optional amount of acceptable loss in Basis Points.\n    // @param strategies Optional array of strategies to withdraw from.\n    // @return The amount of shares actually burnt.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) external override returns (uint256) {\n        uint256 shares = _convertToShares(assets, Rounding.ROUND_UP);\n        _redeem(tx.origin, receiver, owner, assets, shares, maxLoss, _strategies);\n        return shares;\n    }\n\n    // @notice Get the maximum amount of shares that can be redeemed.\n    // @dev Complies to normal 4626 interface and takes custom params.\n    // @param owner The address that owns the shares.\n    // @param max_loss Custom max_loss if any.\n    // @param strategies Custom strategies queue if any.\n    // @return The maximum amount of shares that can be redeemed.\n    function maxRedeem(address owner, uint256 maxLoss, address[] memory _strategies) external override returns (uint256) {\n        uint256 maxWithdrawAmount = _maxWithdraw(owner, maxLoss, _strategies);\n        uint256 sharesEquivalent = _convertToShares(maxWithdrawAmount, Rounding.ROUND_UP);\n        return Math.min(sharesEquivalent, _balanceOf[owner]);\n    }\n\n    // @notice Preview the amount of assets that would be withdrawn for a redeem.\n    // @param shares The amount of shares to redeem.\n    // @return The amount of assets that would be withdrawn.\n    function previewRedeem(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_DOWN);\n    }\n\n    // Used for `deposit` calls to transfer the amount of `asset` to the vault, \n    // issue the corresponding shares to the `recipient` and update all needed \n    // vault accounting.\n    function _deposit(address sender, address recipient, uint256 assets) internal returns (uint256) {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        if (assets > _maxDeposit(recipient)) {\n            revert ExceedDepositLimit();\n        }\n        if (assets <= 0) {\n            revert ZeroValue();\n        }\n\n        // Transfer the tokens to the vault first.\n        ASSET.transferFrom(tx.origin, address(this), assets);\n        // Record the change in total assets.\n        totalIdleAmount += assets;\n\n        // Issue the corresponding shares for assets.\n        uint256 shares = _issueSharesForAmount(assets, recipient);\n        if (shares <= 0) {\n            revert ZeroValue();\n        }\n\n        emit Deposit(sender, recipient, assets, shares);\n        return shares;\n    }\n\n    function deposit(address sender, address recipient, uint256 assets) external override returns (uint256) {\n        return _deposit(sender, recipient, assets);\n    }\n\n    // @notice Get the maximum amount of shares that can be minted.\n    // @param receiver The address that will receive the shares.\n    // @return The maximum amount of shares that can be minted.\n    function maxMint(address receiver) external view override returns (uint256) {\n        uint256 maxDepositAmount = _maxDeposit(receiver);\n        return _convertToShares(maxDepositAmount, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Preview the amount of assets that would be deposited for a mint.\n    // @param shares The amount of shares to mint.\n    // @return The amount of assets that would be deposited.\n    function previewMint(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_UP);\n    }\n\n    // Used for `mint` calls to issue the corresponding shares to the `recipient`,\n    // transfer the amount of `asset` to the vault, and update all needed vault \n    // accounting.\n    function _mint(address sender, address recipient, uint256 shares) internal returns (uint256) {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        // Get corresponding amount of assets.\n        uint256 assets = _convertToAssets(shares, Rounding.ROUND_UP);\n\n        if (assets <= 0) {\n            revert ZeroValue();\n        }\n        if (assets > _maxDeposit(recipient)) {\n            revert ExceedDepositLimit();\n        }\n\n        // Transfer the tokens to the vault first.\n        ASSET.transferFrom(msg.sender, address(this), assets);\n        // Record the change in total assets.\n        totalIdleAmount += assets;\n\n        // Issue the corresponding shares for assets.\n        _issueShares(shares, recipient); // Assuming _issueShares is defined elsewhere\n\n        emit Deposit(sender, recipient, assets, shares);\n        return assets;\n    }\n\n    function mint(address sender, address recipient, uint256 shares) external override returns (uint256) {\n        return _mint(sender, recipient, shares);\n    }\n\n    // Returns the share of losses that a user would take if withdrawing from this strategy\n    // e.g. if the strategy has unrealised losses for 10% of its current debt and the user \n    // wants to withdraw 1000 tokens, the losses that he will take are 100 token\n    function _assessShareOfUnrealisedLosses(address strategy, uint256 assetsNeeded) internal view returns (uint256) {\n        // Minimum of how much debt the debt should be worth.\n        uint256 strategyCurrentDebt = strategies[strategy].currentDebt;\n        // The actual amount that the debt is currently worth.\n        uint256 vaultShares = IStrategy(strategy).balanceOf(address(this));\n        uint256 strategyAssets = IStrategy(strategy).convertToAssets(vaultShares);\n\n        // If no losses, return 0\n        if (strategyAssets >= strategyCurrentDebt || strategyCurrentDebt == 0) {\n            return 0;\n        }\n\n        // Users will withdraw assets_to_withdraw divided by loss ratio (strategy_assets / strategy_current_debt - 1),\n        // but will only receive assets_to_withdraw.\n        // NOTE: If there are unrealised losses, the user will take his share.\n        uint256 numerator = assetsNeeded * strategyAssets;\n        uint256 lossesUserShare = assetsNeeded - numerator / strategyCurrentDebt;\n\n        // Always round up.\n        if (numerator % strategyCurrentDebt != 0) {\n            lossesUserShare += 1;\n        }\n\n        return lossesUserShare;\n    }\n\n    function assessShareOfUnrealisedLosses(address strategy, uint256 assetsNeeded) external view override returns (uint256) {\n        // Assuming strategies mapping and _assess_share_of_unrealised_losses are defined\n        if (strategies[strategy].currentDebt < assetsNeeded) {\n            revert StrategyDebtIsLessThanAssetsNeeded();\n        }\n        return _assessShareOfUnrealisedLosses(strategy, assetsNeeded);\n    }\n\n    // This takes the amount denominated in asset and performs a {redeem}\n    // with the corresponding amount of shares.\n    // We use {redeem} to natively take on losses without additional non-4626 standard parameters.\n    function _withdrawFromStrategy(address strategy, uint256 assetsToWithdraw) internal {\n        // Need to get shares since we use redeem to be able to take on losses.\n        uint256 sharesToRedeem = Math.min(\n            IStrategy(strategy).previewWithdraw(assetsToWithdraw), // Use previewWithdraw since it should round up.\n            IStrategy(strategy).balanceOf(address(this)) // And check against our actual balance.\n        );\n\n        // Redeem the shares.\n        IStrategy(strategy).redeem(sharesToRedeem, address(this), address(this));\n    }\n\n    function withdrawFromStrategy(address strategy, uint256 assetsToWithdraw) external override {\n        _withdrawFromStrategy(strategy, assetsToWithdraw);\n    }\n\n    // This will attempt to free up the full amount of assets equivalent to\n    // `shares_to_burn` and transfer them to the `receiver`. If the vault does\n    // not have enough idle funds it will go through any strategies provided by\n    // either the withdrawer or the queue_manager to free up enough funds to \n    // service the request.\n    // The vault will attempt to account for any unrealized losses taken on from\n    // strategies since their respective last reports.\n    // Any losses realized during the withdraw from a strategy will be passed on\n    // to the user that is redeeming their vault shares.\n    function _redeem(\n        address sender,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 sharesToBurn,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) internal returns (uint256) {\n        _validateRedeem(receiver, owner, sharesToBurn, maxLoss);\n        _handleAllowance(owner, sender, sharesToBurn);\n        (uint256 requestedAssets, uint256 currTotalIdle) = _withdrawAssets(assets, _strategies);\n        _finalizeRedeem(receiver, owner, sharesToBurn, assets, requestedAssets, currTotalIdle, maxLoss);\n        \n        emit Withdraw(sender, receiver, owner, requestedAssets, sharesToBurn);\n        return requestedAssets;\n    }\n\n    // Validates the state and inputs for the redeem operation.\n    function _validateRedeem(\n        address receiver,\n        address owner,\n        uint256 sharesToBurn,\n        uint256 maxLoss\n    ) internal view {\n        if (receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        if (maxLoss > MAX_BPS) {\n            revert MaxLoss();\n        }\n        if (sharesToBurn <= 0) {\n            revert ZeroValue();\n        }\n        if (_balanceOf[owner] < sharesToBurn) {\n            revert InsufficientShares();\n        }\n    }\n\n    // Handles the allowance check and spending.\n    function _handleAllowance(address owner, address sender, uint256 sharesToBurn) internal {\n        if (sender != owner) {\n            _spendAllowance(owner, sender, sharesToBurn);\n        }\n    }\n\n    // Withdraws assets from strategies as needed and handles unrealized losses.\n    function _withdrawAssets(uint256 assets, address[] memory _strategies) internal returns (uint256, uint256) {\n        // Initialize the state struct\n        WithdrawalState memory state = WithdrawalState({\n            requestedAssets: assets,\n            currTotalIdle: totalIdleAmount,\n            currTotalDebt: totalDebtAmount,\n            assetsNeeded: 0,\n            previousBalance: ASSET.balanceOf(address(this)),\n            unrealisedLossesShare: 0\n        });\n\n        // If there are not enough assets in the Vault contract, we try to free\n        // funds from strategies.\n        if (state.requestedAssets > state.currTotalIdle) {\n            // Cache the default queue.\n            address[] memory currentStrategies = _strategies.length != 0 && !useDefaultQueue ? _strategies : defaultQueue;\n\n            // Withdraw from strategies only what idle doesn't cover.\n            // `assetsNeeded` is the total amount we need to fill the request.\n            state.assetsNeeded = state.requestedAssets - state.currTotalIdle;\n\n            // Assuming _strategies is an array of addresses representing the strategies\n            for (uint256 i = 0; i < currentStrategies.length; i++) {\n                address strategy = currentStrategies[i];\n                \n                // Make sure we have a valid strategy.\n                if (strategies[strategy].activation == 0) {\n                    revert InactiveStrategy();\n                }\n\n                // How much should the strategy have.\n                uint256 currentDebt = strategies[strategy].currentDebt;\n\n                // What is the max amount to withdraw from this strategy.\n                uint256 assetsToWithdraw = Math.min(state.assetsNeeded, currentDebt);\n\n                // Cache max_withdraw now for use if unrealized loss > 0\n                // Use maxRedeem and convert since we use redeem.\n                uint256 currMaxWithdraw = IStrategy(strategy).convertToAssets(\n                    IStrategy(strategy).maxRedeem(address(this))\n                );\n\n                // CHECK FOR UNREALIZED LOSSES\n                // If unrealised losses > 0, then the user will take the proportional share \n                // and realize it (required to avoid users withdrawing from lossy strategies).\n                // NOTE: strategies need to manage the fact that realising part of the loss can \n                // mean the realisation of 100% of the loss!! (i.e. if for withdrawing 10% of the\n                // strategy it needs to unwind the whole position, generated losses might be bigger)\n                uint256 unrealisedLossesShare = _assessShareOfUnrealisedLosses(strategy, assetsToWithdraw);\n                if (unrealisedLossesShare > 0) {\n                    // If max withdraw is limiting the amount to pull, we need to adjust the portion of \n                    // the unrealized loss the user should take.\n                    if (currMaxWithdraw < assetsToWithdraw - unrealisedLossesShare) {\n                        // How much would we want to withdraw\n                        uint256 wanted = assetsToWithdraw - unrealisedLossesShare;\n                        // Get the proportion of unrealised comparing what we want vs. what we can get\n                        unrealisedLossesShare = unrealisedLossesShare * currMaxWithdraw / wanted;\n                        // Adjust assetsToWithdraw so all future calculations work correctly\n                        assetsToWithdraw = currMaxWithdraw + unrealisedLossesShare;\n                    }\n                    \n                    // User now \"needs\" less assets to be unlocked (as he took some as losses)\n                    assetsToWithdraw -= unrealisedLossesShare;\n                    state.requestedAssets -= unrealisedLossesShare;\n                    // NOTE: done here instead of waiting for regular update of these values \n                    // because it's a rare case (so we can save minor amounts of gas)\n                    state.assetsNeeded -= unrealisedLossesShare;\n                    state.currTotalDebt -= unrealisedLossesShare;\n\n                    // If max withdraw is 0 and unrealised loss is still > 0 then the strategy likely\n                    // realized a 100% loss and we will need to realize that loss before moving on.\n                    if (currMaxWithdraw == 0 && unrealisedLossesShare > 0) {\n                        // Adjust the strategy debt accordingly.\n                        uint256 newDebt = currentDebt - unrealisedLossesShare;\n\n                        // Update strategies storage\n                        strategies[strategy].currentDebt = newDebt;\n\n                        // Log the debt update\n                        emit DebtUpdated(strategy, currentDebt, newDebt);\n                    }\n                }\n\n                // Adjust based on the max withdraw of the strategy.\n                assetsToWithdraw = Math.min(assetsToWithdraw, currMaxWithdraw);\n\n                // Can't withdraw 0.\n                if (assetsToWithdraw == 0) {\n                    continue;\n                }\n\n                // WITHDRAW FROM STRATEGY\n                _withdrawFromStrategy(strategy, assetsToWithdraw);\n                uint256 postBalance = ASSET.balanceOf(address(this));\n                \n                // Always check withdrawn against the real amounts.\n                uint256 withdrawn = postBalance - state.previousBalance;\n                uint256 loss = 0;\n                // Check if we redeemed too much.\n                if (withdrawn > assetsToWithdraw) {\n                    // Make sure we don't underflow in debt updates.\n                    if (withdrawn > currentDebt) {\n                        // Can't withdraw more than our debt.\n                        assetsToWithdraw = currentDebt;\n                    } else {\n                        assetsToWithdraw += withdrawn - assetsToWithdraw;\n                    }\n                // If we have not received what we expected, we consider the difference a loss.\n                } else if (withdrawn < assetsToWithdraw) {\n                    loss = assetsToWithdraw - withdrawn;\n                }\n\n                // NOTE: strategy's debt decreases by the full amount but the total idle increases \n                // by the actual amount only (as the difference is considered lost).\n                state.currTotalIdle += assetsToWithdraw - loss;\n                state.requestedAssets -= loss;\n                state.currTotalDebt -= assetsToWithdraw;\n\n                // Vault will reduce debt because the unrealised loss has been taken by user\n                uint256 _newDebt = currentDebt - (assetsToWithdraw + unrealisedLossesShare);\n\n                // Update strategies storage\n                strategies[strategy].currentDebt = _newDebt;\n                // Log the debt update\n                emit DebtUpdated(strategy, currentDebt, _newDebt);\n\n                // Break if we have enough total idle to serve initial request.\n                if (state.requestedAssets <= state.currTotalIdle) {\n                    break;\n                }\n\n                // We update the previous_balance variable here to save gas in next iteration.\n                state.previousBalance = postBalance;\n\n                // Reduce what we still need. Safe to use assets_to_withdraw \n                // here since it has been checked against requested_assets\n                state.assetsNeeded -= assetsToWithdraw;\n            }\n\n            // If we exhaust the queue and still have insufficient total idle, revert.\n            if (state.currTotalIdle < state.requestedAssets) {\n                revert InsufficientAssets();\n            }\n\n            // Commit memory to storage.\n            totalDebtAmount = state.currTotalDebt;\n        }\n\n        return (state.requestedAssets, state.currTotalIdle);\n    }\n\n    // Finalizes the redeem operation by burning shares and transferring assets.\n    function _finalizeRedeem(\n        address receiver,\n        address owner,\n        uint256 sharesToBurn,\n        uint256 assets,\n        uint256 requestedAssets,\n        uint256 currTotalIdle,\n        uint256 maxLoss\n    ) internal {\n        // Check if there is a loss and a non-default value was set.\n        if (assets > requestedAssets && maxLoss < MAX_BPS) {\n            // Assure the loss is within the allowed range.\n            if (assets - requestedAssets > assets * maxLoss / MAX_BPS) {\n                revert TooMuchLoss();\n            }\n        }\n\n        // First burn the corresponding shares from the redeemer.\n        _burnShares(sharesToBurn, owner);\n        // Commit memory to storage.\n        totalIdleAmount = currTotalIdle - requestedAssets;\n        // Transfer the requested amount to the receiver.\n        _erc20SafeTransfer(address(ASSET), receiver, requestedAssets);\n    }\n\n    // ## ERC20+4626 compatibility\n\n    // @notice Get the address of the asset.\n    // @return The address of the asset.\n    function asset() external view override returns (address) {\n        return address(ASSET);\n    }\n\n    // @notice Get the number of decimals of the asset/share.\n    // @return The number of decimals of the asset/share.\n    function decimals() external view override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    // @notice Approve an address to spend the vault's shares.\n    // @param spender The address to approve.\n    // @param amount The amount of shares to approve.\n    // @return True if the approval was successful.\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        return _approve(msg.sender, spender, amount);\n    }\n\n    // @notice Convert an amount of shares to assets.\n    // @param shares The amount of shares to convert.\n    // @return The amount of assets.\n    function convertToAssets(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Convert an amount of assets to shares.\n    // @param assets The amount of assets to convert.\n    // @return The amount of shares.\n    function convertToShares(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Deposit assets into the vault.\n    // @param assets The amount of assets to deposit.\n    // @param receiver The address to receive the shares.\n    // @return The amount of shares minted.\n    function deposit(uint256 assets, address receiver) external override nonReentrant returns (uint256) {\n        return _deposit(msg.sender, receiver, assets);\n    }\n\n    // @notice Mint shares for the receiver.\n    // @param shares The amount of shares to mint.\n    // @param receiver The address to receive the shares.\n    // @return The amount of assets deposited.\n    function mint(uint256 shares, address receiver) external override nonReentrant returns (uint256) {\n        return _mint(msg.sender, receiver, shares);\n    }\n\n    // @notice Transfer shares to a receiver.\n    // @param receiver The address to transfer shares to.\n    // @param amount The amount of shares to transfer.\n    // @return True if the transfer was successful.\n    function transfer(address receiver, uint256 amount) external override returns (bool) {\n        if (receiver == address(this) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    // @notice Redeems an amount of shares of `owners` shares sending funds to `receiver`.\n    // @dev The default behavior is to allow losses to be realized.\n    // @param shares The amount of shares to burn.\n    // @param receiver The address to receive the assets.\n    // @param owner The address who's shares are being burnt.\n    // @param max_loss Optional amount of acceptable loss in Basis Points.\n    // @param strategies Optional array of strategies to withdraw from.\n    // @return The amount of assets actually withdrawn.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) external override nonReentrant returns (uint256) {\n        uint256 assets = _convertToAssets(shares, Rounding.ROUND_DOWN);\n        // Always return the actual amount of assets withdrawn.\n        return _redeem(tx.origin, receiver, owner, assets, shares, maxLoss, _strategies);\n    }\n\n    // Calculate share management based on gains, losses, and fees.\n    function calculateShareManagement(uint256 loss, uint256 totalFees, uint256 protocolFees) external override view returns (ShareManagement memory) {\n        // `shares_to_burn` is derived from amounts that would reduce the vaults PPS.\n        // NOTE: this needs to be done before any pps changes\n        ShareManagement memory shares;\n\n        // Only need to burn shares if there is a loss or fees.\n        if (loss + totalFees > 0) {\n            // The amount of shares we will want to burn to offset losses and fees.\n            shares.sharesToBurn += _convertToShares(loss + totalFees, Rounding.ROUND_UP);\n\n            // Vault calculates the amount of shares to mint as fees before changing totalAssets / totalSupply.\n            if (totalFees > 0) {\n                // Accountant fees are total fees - protocol fees.\n                shares.accountantFeesShares = _convertToShares(totalFees - protocolFees, Rounding.ROUND_DOWN);\n                if (protocolFees > 0) {\n                    shares.protocolFeesShares = _convertToShares(protocolFees, Rounding.ROUND_DOWN);\n                }\n            }\n        }\n\n        return shares;\n    }\n\n    // Handle the burning and issuing of shares based on the strategy's report.\n    function handleShareBurnsAndIssues(\n        ShareManagement memory shares, \n        FeeAssessment memory fees, \n        uint256 gain, \n        uint256 loss, \n        address strategy\n    ) external override returns (uint256 previouslyLockedShares, uint256 newlyLockedShares) {\n        // Shares to lock is any amounts that would otherwise increase the vaults PPS.\n        uint256 _newlyLockedShares;\n        if (fees.totalRefunds > 0) {\n            // Make sure we have enough approval and enough asset to pull.\n            fees.totalRefunds = Math.min(fees.totalRefunds, Math.min(ISharesManager(sharesManager).balanceOf(accountant), ISharesManager(sharesManager).allowance(accountant, address(this))));\n            // Transfer the refunded amount of asset to the vault.\n            _erc20SafeTransferFrom(sharesManager, accountant, address(this), fees.totalRefunds);\n            // Update storage to increase total assets.\n            totalIdleAmount += fees.totalRefunds;\n        }\n\n        // Record any reported gains.\n        if (gain > 0) {\n            // NOTE: this will increase total_assets\n            strategies[strategy].currentDebt += gain;\n            totalDebtAmount += gain;\n        }\n\n        // Mint anything we are locking to the vault.\n        if (gain + fees.totalRefunds > 0 && profitMaxUnlockTime != 0) {\n            _newlyLockedShares = _issueSharesForAmount(gain + fees.totalRefunds, address(this));\n        }\n\n        // Strategy is reporting a loss\n        if (loss > 0) {\n            strategies[strategy].currentDebt -= loss;\n            totalDebtAmount -= loss;\n        }\n\n        // NOTE: should be precise (no new unlocked shares due to above's burn of shares)\n        // newly_locked_shares have already been minted / transferred to the vault, so they need to be subtracted\n        // no risk of underflow because they have just been minted.\n        uint256 _previouslyLockedShares = _balanceOf[address(this)] - _newlyLockedShares;\n\n        // Now that pps has updated, we can burn the shares we intended to burn as a result of losses/fees.\n        // NOTE: If a value reduction (losses / fees) has occurred, prioritize burning locked profit to avoid\n        // negative impact on price per share. Price per share is reduced only if losses exceed locked value.\n        if (shares.sharesToBurn > 0) {\n            // Cant burn more than the vault owns.\n            shares.sharesToBurn = Math.min(shares.sharesToBurn, _previouslyLockedShares + _newlyLockedShares);\n            _burnShares(shares.sharesToBurn, address(this));\n\n            // We burn first the newly locked shares, then the previously locked shares.\n            uint256 sharesNotToLock = Math.min(shares.sharesToBurn, _newlyLockedShares);\n            // Reduce the amounts to lock by how much we burned\n            _newlyLockedShares -= sharesNotToLock;\n            _previouslyLockedShares -= (shares.sharesToBurn - sharesNotToLock);\n        }\n\n        // Issue shares for fees that were calculated above if applicable.\n        if (shares.accountantFeesShares > 0) {\n            _issueShares(shares.accountantFeesShares, accountant);\n        }\n\n        if (shares.protocolFeesShares > 0) {\n            _issueShares(shares.protocolFeesShares, fees.protocolFeeRecipient);\n        }\n\n        return (_previouslyLockedShares, _newlyLockedShares);\n    }\n\n    // Manage the unlocking of shares over time based on the vault's configuration.\n    function manageUnlockingOfShares(uint256 previouslyLockedShares, uint256 newlyLockedShares) external override {\n        // Update unlocking rate and time to fully unlocked.\n        uint256 totalLockedShares = previouslyLockedShares + newlyLockedShares;\n        if (totalLockedShares > 0) {\n            uint256 previouslyLockedTime = 0;\n            // Check if we need to account for shares still unlocking.\n            if (fullProfitUnlockDate > block.timestamp) {\n                // There will only be previously locked shares if time remains.\n                // We calculate this here since it will not occur every time we lock shares.\n                previouslyLockedTime = previouslyLockedShares * (fullProfitUnlockDate - block.timestamp);\n            }\n\n            // newProfitLockingPeriod is a weighted average between the remaining time of the previously locked shares and the profitMaxUnlockTime\n            uint256 newProfitLockingPeriod = (previouslyLockedTime + newlyLockedShares * profitMaxUnlockTime) / totalLockedShares;\n            // Calculate how many shares unlock per second.\n            profitUnlockingRate = totalLockedShares * MAX_BPS_EXTENDED / newProfitLockingPeriod;\n            // Calculate how long until the full amount of shares is unlocked.\n            fullProfitUnlockDate = block.timestamp + newProfitLockingPeriod;\n            // Update the last profitable report timestamp.\n            lastProfitUpdate = block.timestamp;\n        } else {\n            // NOTE: only setting this to 0 will turn in the desired effect, no need \n            // to update last_profit_update or full_profit_unlock_date\n            profitUnlockingRate = 0;\n        }\n    }\n\n    // @notice Set the new deposit limit.\n    // @dev Can not be changed if a deposit_limit_module\n    //  is set or if shutdown.\n    // @param deposit_limit The new deposit limit.\n    function setDepositLimit(uint256 _depositLimit) external override {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        if (depositLimitModule != address(0)) {\n            revert UsingModule();\n        }\n        depositLimit = _depositLimit;\n        emit UpdateDepositLimit(_depositLimit);\n    }\n}\n    "
    },
    "contracts/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL 3.0\n// Copyright Fathom 2023\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./VaultStructs.sol\";\n\ncontract VaultStorage {\n    // CONSTANTS\n    // The max length the withdrawal queue can be.\n    uint256 public constant MAX_QUEUE = 10;\n    // 100% in Basis Points.\n    uint256 public constant MAX_BPS = 10000;\n    // Extended for profit locking calculations.\n    uint256 public constant MAX_BPS_EXTENDED = 1000000000000;\n    // The version of this vault.\n    string public constant API_VERSION = \"1.0.0\";\n    uint256 public immutable ONE_YEAR = 31556952;\n\n    address public strategyManager;\n    address public sharesManager;\n    address public setters;\n    address public governance;\n\n    // STORAGE\n    // HashMap that records all the strategies that are allowed to receive assets from the vault.\n    mapping(address => StrategyParams) public strategies;\n\n    // The current default withdrawal queue.\n    address[] public defaultQueue;\n\n    // Should the vault use the default_queue regardless whats passed in.\n    bool public useDefaultQueue;\n\n    // ERC20 - amount of shares per account\n    mapping(address => uint256) internal _balanceOf;\n    // ERC20 - owner -> (spender -> amount)\n    mapping(address => mapping(address => uint256)) internal _allowance;\n\n    // Total amount of shares that are currently minted including those locked.\n    // NOTE: To get the ERC20 compliant version use totalSupply().\n    uint256 public totalSupplyAmount;\n\n    // Total amount of assets that has been deposited in strategies.\n    uint256 public totalDebtAmount;\n    // Current assets held in the vault contract. Replacing balanceOf(this) to avoid price_per_share manipulation.\n    uint256 public totalIdleAmount;\n    // Minimum amount of assets that should be kept in the vault contract to allow for fast, cheap redeems.\n    uint256 public minimumTotalIdle;\n    // Maximum amount of tokens that the vault can accept. If totalAssets > deposit_limit, deposits will revert.\n    uint256 public depositLimit;\n    // Contract that charges fees and can give refunds.\n    address public accountant;\n    // Contract to control the deposit limit.\n    address public depositLimitModule;\n    // Contract to control the withdraw limit.\n    address public withdrawLimitModule;\n\n    // HashMap mapping addresses to their roles\n    mapping(address => bytes32) public roles;\n    // HashMap mapping roles to their permissioned state. If false, the role is not open to the public.\n    mapping(bytes32 => bool) public openRoles;\n\n    // Address that can add and remove roles to addresses.\n    address public roleManager;\n    // Temporary variable to store the address of the next role_manager until the role is accepted.\n    address public futureRoleManager;\n\n    // State of the vault - if set to true, only withdrawals will be available. It can't be reverted.\n    bool public shutdown;\n    // The amount of time profits will unlock over.\n    uint256 public profitMaxUnlockTime;\n    // The timestamp of when the current unlocking period ends.\n    uint256 public fullProfitUnlockDate;\n    // The per second rate at which profit will unlock.\n    uint256 public profitUnlockingRate;\n    // Last timestamp of the most recent profitable report.\n    uint256 public lastProfitUpdate;\n\n    // EIP-2612 permit() nonces and typehashes\n    mapping(address => uint256) public nonces;\n    bytes32 public constant DOMAIN_TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPE_HASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // Roles\n    bytes32 public constant ACCOUNTANT_MANAGER = keccak256(\"ACCOUNTANT_MANAGER\");\n    bytes32 public constant QUEUE_MANAGER = keccak256(\"QUEUE_MANAGER\");\n    bytes32 public constant DEPOSIT_LIMIT_MANAGER = keccak256(\"DEPOSIT_LIMIT_MANAGER\");\n    bytes32 public constant WITHDRAW_LIMIT_MANAGER = keccak256(\"WITHDRAW_LIMIT_MANAGER\");\n    bytes32 public constant MINIMUM_IDLE_MANAGER = keccak256(\"MINIMUM_IDLE_MANAGER\");\n    bytes32 public constant PROFIT_UNLOCK_MANAGER = keccak256(\"PROFIT_UNLOCK_MANAGER\");\n    bytes32 public constant ROLE_MANAGER = keccak256(\"ROLE_MANAGER\");\n    bytes32 public constant REPORTING_MANAGER = keccak256(\"REPORTING_MANAGER\");\n    bytes32 public constant DEBT_PURCHASER = keccak256(\"DEBT_PURCHASER\");\n    bytes32 public constant ADD_STRATEGY_MANAGER = keccak256(\"ADD_STRATEGY_MANAGER\");\n    bytes32 public constant REVOKE_STRATEGY_MANAGER = keccak256(\"REVOKE_STRATEGY_MANAGER\");\n    bytes32 public constant FORCE_REVOKE_MANAGER = keccak256(\"FORCE_REVOKE_MANAGER\");\n    bytes32 public constant MAX_DEBT_MANAGER = keccak256(\"MAX_DEBT_MANAGER\");\n    bytes32 public constant DEBT_MANAGER = keccak256(\"DEBT_MANAGER\");\n    bytes32 public constant EMERGENCY_MANAGER = keccak256(\"EMERGENCY_MANAGER\");         \n}"
    },
    "contracts/VaultStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL 3.0\n// Copyright Fathom 2023\n\npragma solidity ^0.8.16;\n\nstruct StrategyParams {\n    uint256 activation;\n    uint256 lastReport;\n    uint256 currentDebt;\n    uint256 maxDebt;\n}\n\nstruct FeeAssessment {\n    uint256 totalFees;\n    uint256 totalRefunds;\n    uint256 protocolFees;\n    address protocolFeeRecipient;\n}\n\nstruct ShareManagement {\n    uint256 sharesToBurn;\n    uint256 accountantFeesShares;\n    uint256 protocolFeesShares;\n}\n\nstruct WithdrawalState {\n    uint256 requestedAssets;\n    uint256 currTotalIdle;\n    uint256 currTotalDebt;\n    uint256 assetsNeeded;\n    uint256 previousBalance;\n    uint256 unrealisedLossesShare;\n}\n\n// ENUMS\nenum StrategyChangeType {\n    ADDED, // Corresponds to the strategy being added.\n    REVOKED // Corresponds to the strategy being revoked.\n}\n\nenum RoleStatusChange {\n    OPENED, // Corresponds to a role being opened.\n    CLOSED // Corresponds to a role being closed.\n}\n\nenum Rounding {\n    ROUND_DOWN, // Corresponds to rounding down to the nearest whole number.\n    ROUND_UP // Corresponds to rounding up to the nearest whole number.\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}