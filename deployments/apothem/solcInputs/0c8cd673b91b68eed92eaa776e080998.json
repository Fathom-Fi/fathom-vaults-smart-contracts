{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/FathomVault.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./Interfaces/IVault.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./VaultStorage.sol\";\nimport \"./Interfaces/IVaultEvents.sol\";\nimport \"./Interfaces/IAccountant.sol\";\nimport \"./Interfaces/IStrategy.sol\";\nimport \"./Interfaces/IDepositLimitModule.sol\";\nimport \"./Interfaces/IWithdrawLimitModule.sol\";\nimport \"./Interfaces/IFactory.sol\";\nimport \"./Interfaces/IStrategyManager.sol\";\nimport \"./Interfaces/ISharesManager.sol\";\nimport \"./Interfaces/ISetters.sol\";\nimport \"./Interfaces/IGovernance.sol\";\n\n/**\n@title Yearn V3 Vault\n@notice The Yearn VaultV3 is designed as a non-opinionated system to distribute funds of \ndepositors for a specific `asset` into different opportunities (aka Strategies)\nand manage accounting in a robust way.\n*/\n\n// Solidity version of the Vyper contract\ncontract FathomVault is AccessControl, IVault, ReentrancyGuard, VaultStorage, IVaultEvents {\n    // solhint-disable not-rely-on-time\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    // solhint-disable var-name-mixedcase\n    // solhint-disable max-line-length\n    // solhint-disable ordering\n\n    // Factory address\n    address public immutable FACTORY;\n\n    error ProfitUnlockTimeTooLong();\n    error InsufficientFunds();\n    error ZeroAddress();\n    error MaxLoss();\n\n\n    // Constructor\n    constructor(\n        uint256 _profitMaxUnlockTime,\n        address _strategyManagerAddress,\n        address _sharesManagerAddress,\n        address _settersAddress,\n        address _governanceAddress\n    ) {\n        FACTORY = msg.sender;\n        // Must be less than one year for report cycles\n        if (_profitMaxUnlockTime > ONE_YEAR) {\n            revert ProfitUnlockTimeTooLong();\n        }\n\n        profitMaxUnlockTime = _profitMaxUnlockTime;\n        strategyManager = _strategyManagerAddress;\n        sharesManager = _sharesManagerAddress;\n        setters = _settersAddress;\n        governance = _governanceAddress;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEPOSIT_LIMIT_MANAGER, msg.sender);\n        _grantRole(ADD_STRATEGY_MANAGER, msg.sender);\n        _grantRole(MAX_DEBT_MANAGER, msg.sender);\n        _grantRole(DEBT_MANAGER, msg.sender);\n        _grantRole(REPORTING_MANAGER, msg.sender);\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_HASH,\n                keccak256(bytes(ISharesManager(sharesManager).name())), // \"Yearn Vault\" in the example\n                keccak256(bytes(API_VERSION)), // API_VERSION in the example\n                block.chainid, // Current chain ID\n                address(this) // Address of the contract\n            )\n        );\n\n    }\n\n    // SHARE MANAGEMENT\n    // ERC20\n    function _burnShares(uint256 shares, address owner) internal {\n        ISharesManager(sharesManager).burnShares(shares, owner);\n    }\n\n    // assets = shares * (total_assets / total_supply) --- (== price_per_share * shares)\n    function _convertToAssets(uint256 shares, Rounding rounding) internal view returns (uint256) {\n        return ISharesManager(sharesManager).convertToAssets(shares, rounding);\n    }\n\n    // shares = amount * (total_supply / total_assets) --- (== amount / price_per_share)\n    function _convertToShares(uint256 assets, Rounding rounding) internal view returns (uint256) {\n        return ISharesManager(sharesManager).convertToShares(assets, rounding);\n    }\n\n    // Used only to transfer tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function _erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) internal {\n        ISharesManager(sharesManager).erc20SafeTransferFrom(token, sender, receiver, amount);\n    }\n\n    // Used only to send tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function _erc20SafeTransfer(address token, address receiver, uint256 amount) internal {\n        ISharesManager(sharesManager).erc20SafeTransfer(token, receiver, amount);\n    }\n\n    function _issueShares(uint256 shares, address recipient) internal {\n        ISharesManager(sharesManager).issueShares(shares, recipient);\n    }\n\n    // Issues shares that are worth 'amount' in the underlying token (asset).\n    // WARNING: this takes into account that any new assets have been summed \n    // to total_assets (otherwise pps will go down).\n    function _issueSharesForAmount(uint256 amount, address recipient) internal returns (uint256) {\n        return ISharesManager(sharesManager).issueSharesForAmount(amount, recipient);\n    }\n\n    // SETTERS\n    // @notice Set the new accountant address.\n    // @param new_accountant The new accountant address.\n    function setAccountant(address newAccountant) external override onlyRole(ACCOUNTANT_MANAGER) {\n        ISetters(setters).setAccountant(newAccountant);\n    }\n\n    // @notice Set the new default queue array.\n    // @dev Will check each strategy to make sure it is active.\n    // @param new_default_queue The new default queue array.\n    function setDefaultQueue(address[] calldata newDefaultQueue) external override onlyRole(QUEUE_MANAGER) {\n        ISetters(setters).setDefaultQueue(newDefaultQueue);\n    }\n\n    // @notice Set a new value for `use_default_queue`.\n    // @dev If set `True` the default queue will always be\n    //  used no matter whats passed in.\n    // @param use_default_queue new value.\n    function setUseDefaultQueue(bool _useDefaultQueue) external override onlyRole(QUEUE_MANAGER) {\n        ISetters(setters).setUseDefaultQueue(_useDefaultQueue);\n    }\n\n    // @notice Set the new deposit limit.\n    // @dev Can not be changed if a deposit_limit_module\n    //  is set or if shutdown.\n    // @param deposit_limit The new deposit limit.\n    function setDepositLimit(uint256 _depositLimit) external override onlyRole(DEPOSIT_LIMIT_MANAGER) {\n        ISetters(setters).setDepositLimit(_depositLimit);\n    }\n\n    // @notice Set a contract to handle the deposit limit.\n    // @dev The default `deposit_limit` will need to be set to\n    //  max uint256 since the module will override it.\n    // @param deposit_limit_module Address of the module.\n    function setDepositLimitModule(address _depositLimitModule) external override onlyRole(DEPOSIT_LIMIT_MANAGER) {\n        ISetters(setters).setDepositLimitModule(_depositLimitModule);\n    }\n\n    // @notice Set a contract to handle the withdraw limit.\n    // @dev This will override the default `max_withdraw`.\n    // @param withdraw_limit_module Address of the module.\n    function setWithdrawLimitModule(address _withdrawLimitModule) external override onlyRole(WITHDRAW_LIMIT_MANAGER) {\n        ISetters(setters).setWithdrawLimitModule(_withdrawLimitModule);\n    }\n\n    // @notice Set the new minimum total idle.\n    // @param minimum_total_idle The new minimum total idle.\n    function setMinimumTotalIdle(uint256 _minimumTotalIdle) external override onlyRole(MINIMUM_IDLE_MANAGER) {\n        ISetters(setters).setMinimumTotalIdle(_minimumTotalIdle);\n    }\n\n    // @notice Set the new profit max unlock time.\n    // @dev The time is denominated in seconds and must be less than 1 year.\n    //  We only need to update locking period if setting to 0,\n    //  since the current period will use the old rate and on the next\n    //  report it will be reset with the new unlocking time.\n    \n    //  Setting to 0 will cause any currently locked profit to instantly\n    //  unlock and an immediate increase in the vaults Price Per Share.\n\n    // @param new_profit_max_unlock_time The new profit max unlock time.\n    function setProfitMaxUnlockTime(uint256 _newProfitMaxUnlockTime) external override onlyRole(PROFIT_UNLOCK_MANAGER) {\n        ISetters(setters).setProfitMaxUnlockTime(_newProfitMaxUnlockTime);\n    }\n\n    // VAULT STATUS VIEWS - GETTERS\n\n    // @notice Get the amount of shares that have been unlocked.\n    // @return The amount of shares that are have been unlocked.\n    function unlockedShares() external view override returns (uint256) {\n        return ISharesManager(sharesManager).unlockedShares();\n    }\n\n    // @notice Get the price per share (pps) of the vault.\n    // @dev This value offers limited precision. Integrations that require \n    //    exact precision should use convertToAssets or convertToShares instead.\n    // @return The price per share.\n    function pricePerShare() external view override returns (uint256) {\n        return _convertToAssets(10**ISharesManager(sharesManager).decimals(), Rounding.ROUND_DOWN);\n    }\n\n    // REPORTING MANAGEMENT\n    \n    // @notice Process the report of a strategy.\n    // @param strategy The strategy to process the report for.\n    // @return The gain and loss of the strategy.\n    function processReport(address strategy) external override onlyRole(REPORTING_MANAGER) nonReentrant returns (uint256, uint256) {\n        return IStrategyManager(strategyManager).processReport(strategy);\n    }\n\n    // @notice Used for governance to buy bad debt from the vault.\n    // @dev This should only ever be used in an emergency in place\n    //  of force revoking a strategy in order to not report a loss.\n    //  It allows the DEBT_PURCHASER role to buy the strategies debt\n    //  for an equal amount of `asset`. \n\n    // @param strategy The strategy to buy the debt for\n    // @param amount The amount of debt to buy from the vault.\n    function buyDebt(address strategy, uint256 amount) external override onlyRole(DEBT_PURCHASER) nonReentrant {\n        IGovernance(governance).buyDebt(strategy, amount);\n    }\n\n    // STRATEGY MANAGEMENT\n\n    // @notice Add a new strategy.\n    // @param new_strategy The new strategy to add.\n    function addStrategy(address newStrategy) external override onlyRole(ADD_STRATEGY_MANAGER) {\n        IStrategyManager(strategyManager).addStrategy(newStrategy);\n    }\n\n    // @notice Revoke a strategy.\n    // @param strategy The strategy to revoke.\n    function revokeStrategy(address strategy) external override onlyRole(REVOKE_STRATEGY_MANAGER) {\n        IStrategyManager(strategyManager).revokeStrategy(strategy, false);\n    }\n\n    // @notice Force revoke a strategy.\n    // @dev The vault will remove the strategy and write off any debt left \n    //    in it as a loss. This function is a dangerous function as it can force a \n    //    strategy to take a loss. All possible assets should be removed from the \n    //    strategy first via update_debt. If a strategy is removed erroneously it \n    //    can be re-added and the loss will be credited as profit. Fees will apply.\n    // @param strategy The strategy to force revoke.\n    function forceRevokeStrategy(address strategy) external override onlyRole(FORCE_REVOKE_MANAGER) {\n        IStrategyManager(strategyManager).revokeStrategy(strategy, true);\n    }\n\n    // DEBT MANAGEMENT\n\n    // @notice Update the max debt for a strategy.\n    // @param strategy The strategy to update the max debt for.\n    // @param new_max_debt The new max debt for the strategy.\n    function updateMaxDebtForStrategy(address strategy, uint256 newMaxDebt) external override onlyRole(MAX_DEBT_MANAGER) {\n        // Delegate call to StrategyManager\n        IStrategyManager(strategyManager).updateMaxDebtForStrategy(strategy, newMaxDebt);\n    }\n\n    // @notice Update the debt for a strategy.\n    // @param strategy The strategy to update the debt for.\n    // @param target_debt The target debt for the strategy.\n    // @return The amount of debt added or removed.\n    function updateDebt(address strategy, uint256 targetDebt) external override onlyRole(DEBT_MANAGER) nonReentrant returns (uint256) {\n        if (strategies[strategy].currentDebt != targetDebt && totalIdleAmount <= minimumTotalIdle) {\n            revert InsufficientFunds();\n        }\n        return IStrategyManager(strategyManager).updateDebt(strategy, targetDebt);\n    }\n\n    // EMERGENCY MANAGEMENT\n\n    // @notice Shutdown the vault.\n    function shutdownVault() external override onlyRole(EMERGENCY_MANAGER) {\n        IGovernance(governance).shutdownVault();\n    }\n\n    // ## SHARE MANAGEMENT ##\n    // ## ERC20 + ERC4626 ##\n\n    // @notice Deposit assets into the vault.\n    // @param assets The amount of assets to deposit.\n    // @param receiver The address to receive the shares.\n    // @return The amount of shares minted.\n    function deposit(uint256 assets, address receiver) external override nonReentrant returns (uint256) {\n        return ISharesManager(sharesManager).deposit(msg.sender, receiver, assets);\n    }\n\n    // @notice Mint shares for the receiver.\n    // @param shares The amount of shares to mint.\n    // @param receiver The address to receive the shares.\n    // @return The amount of assets deposited.\n    function mint(uint256 shares, address receiver) external override nonReentrant returns (uint256) {\n        return ISharesManager(sharesManager).mint(msg.sender, receiver, shares);\n    }\n\n    // @notice Withdraw an amount of asset to `receiver` burning `owner`s shares.\n    // @dev The default behavior is to not allow any loss.\n    // @param assets The amount of asset to withdraw.\n    // @param receiver The address to receive the assets.\n    // @param owner The address who's shares are being burnt.\n    // @param max_loss Optional amount of acceptable loss in Basis Points.\n    // @param strategies Optional array of strategies to withdraw from.\n    // @return The amount of shares actually burnt.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) external override nonReentrant returns (uint256) {\n        return ISharesManager(sharesManager).withdraw(assets, receiver, owner, maxLoss, _strategies);\n    }\n\n    // @notice Redeems an amount of shares of `owners` shares sending funds to `receiver`.\n    // @dev The default behavior is to allow losses to be realized.\n    // @param shares The amount of shares to burn.\n    // @param receiver The address to receive the assets.\n    // @param owner The address who's shares are being burnt.\n    // @param max_loss Optional amount of acceptable loss in Basis Points.\n    // @param strategies Optional array of strategies to withdraw from.\n    // @return The amount of assets actually withdrawn.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) external override nonReentrant returns (uint256) {\n        return ISharesManager(sharesManager).redeem(shares, receiver, owner, maxLoss, _strategies);\n    }\n\n    // @notice Approve an address to spend the vault's shares.\n    // @param spender The address to approve.\n    // @param amount The amount of shares to approve.\n    // @return True if the approval was successful.\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        return ISharesManager(sharesManager).approve(msg.sender, spender, amount);\n    }\n\n    // @notice Transfer shares to a receiver.\n    // @param receiver The address to transfer shares to.\n    // @param amount The amount of shares to transfer.\n    // @return True if the transfer was successful.\n    function transfer(address receiver, uint256 amount) external override returns (bool) {\n        if (receiver == address(this) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        ISharesManager(sharesManager).transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    // @notice Transfer shares from a sender to a receiver.\n    // @param sender The address to transfer shares from.\n    // @param receiver The address to transfer shares to.\n    // @param amount The amount of shares to transfer.\n    // @return True if the transfer was successful.\n    function transferFrom(address sender, address receiver, uint256 amount) external override returns (bool) {\n        if (receiver == address(this) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        return ISharesManager(sharesManager).transferFrom(sender, receiver, amount);\n    }\n\n    // ## ERC20+4626 compatibility\n\n    // @notice Increase the allowance for a spender.\n    // @param spender The address to increase the allowance for.\n    // @param amount The amount to increase the allowance by.\n    // @return True if the increase was successful.\n    function increaseAllowance(address spender, uint256 amount) external override returns (bool) {\n        return ISharesManager(sharesManager).increaseAllowance(msg.sender, spender, amount);\n    }\n\n    // @notice Decrease the allowance for a spender.\n    // @param spender The address to decrease the allowance for.\n    // @param amount The amount to decrease the allowance by.\n    // @return True if the decrease was successful.\n    function decreaseAllowance(address spender, uint256 amount) external override returns (bool) {\n        return ISharesManager(sharesManager).decreaseAllowance(msg.sender, spender, amount);\n    }\n\n    // @notice Approve an address to spend the vault's shares.\n    // @param owner The address to approve.\n    // @param spender The address to approve.\n    // @param amount The amount of shares to approve.\n    // @param deadline The deadline for the permit.\n    // @param v The v component of the signature.\n    // @param r The r component of the signature.\n    // @param s The s component of the signature.\n    // @return True if the approval was successful.\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (bool) {\n        return ISharesManager(sharesManager).permit(owner, spender, amount, deadline, v, r, s);\n    }\n\n    // @notice Get the balance of a user.\n    // @param addr The address to get the balance of.\n    // @return The balance of the user.\n    function balanceOf(address addr) external view override returns (uint256) {\n        return ISharesManager(sharesManager).balanceOf(addr);\n    }\n\n    // @notice Get the total supply of shares.\n    // @return The total supply of shares.\n    function totalSupply() external view override returns (uint256) {\n        return ISharesManager(sharesManager).totalSupply();\n    }\n\n    // @notice Get the address of the asset.\n    // @return The address of the asset.\n    function asset() external view override returns (address) {\n        return ISharesManager(sharesManager).asset();\n    }\n\n    // @notice Get the number of decimals of the asset/share.\n    // @return The number of decimals of the asset/share.\n    function decimals() external view override returns (uint8) {\n        return ISharesManager(sharesManager).decimals();\n    }\n\n    // @notice Get the total assets held by the vault.\n    // @return The total assets held by the vault.\n    function totalAssets() external view override returns (uint256) {\n        return ISharesManager(sharesManager).totalAssets();\n    }\n\n    // @notice Convert an amount of assets to shares.\n    // @param assets The amount of assets to convert.\n    // @return The amount of shares.\n    function convertToShares(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Preview the amount of shares that would be minted for a deposit.\n    // @param assets The amount of assets to deposit.\n    // @return The amount of shares that would be minted.\n    function previewDeposit(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Preview the amount of assets that would be deposited for a mint.\n    // @param shares The amount of shares to mint.\n    // @return The amount of assets that would be deposited.\n    function previewMint(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_UP);\n    }\n\n    // @notice Convert an amount of shares to assets.\n    // @param shares The amount of shares to convert.\n    // @return The amount of assets.\n    function convertToAssets(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Get the maximum amount of assets that can be deposited.\n    // @param receiver The address that will receive the shares.\n    // @return The maximum amount of assets that can be deposited.\n    function maxDeposit(address receiver) external view override returns (uint256) {\n        return ISharesManager(sharesManager).maxDeposit(receiver);\n    }\n\n    // @notice Get the maximum amount of shares that can be minted.\n    // @param receiver The address that will receive the shares.\n    // @return The maximum amount of shares that can be minted.\n    function maxMint(address receiver) external view override returns (uint256) {\n        return ISharesManager(sharesManager).maxMint(receiver);\n    }\n\n    // @notice Get the maximum amount of assets that can be withdrawn.\n    // @dev Complies to normal 4626 interface and takes custom params.\n    // @param owner The address that owns the shares.\n    // @param max_loss Custom max_loss if any.\n    // @param strategies Custom strategies queue if any.\n    // @return The maximum amount of assets that can be withdrawn.\n    function maxWithdraw(address owner, uint256 maxLoss, address[] memory _strategies) external override returns (uint256) {\n        return ISharesManager(sharesManager).maxWithdraw(owner, maxLoss, _strategies);\n    }\n\n    // @notice Get the maximum amount of shares that can be redeemed.\n    // @dev Complies to normal 4626 interface and takes custom params.\n    // @param owner The address that owns the shares.\n    // @param max_loss Custom max_loss if any.\n    // @param strategies Custom strategies queue if any.\n    // @return The maximum amount of shares that can be redeemed.\n    function maxRedeem(address owner, uint256 maxLoss, address[] memory _strategies) external override returns (uint256) {\n        return ISharesManager(sharesManager).maxRedeem(owner, maxLoss, _strategies);\n    }\n\n    // @notice Preview the amount of shares that would be redeemed for a withdraw.\n    // @param assets The amount of assets to withdraw.\n    // @return The amount of shares that would be redeemed.\n    function previewWithdraw(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_UP);\n    }\n\n    // @notice Preview the amount of assets that would be withdrawn for a redeem.\n    // @param shares The amount of shares to redeem.\n    // @return The amount of assets that would be withdrawn.\n    function previewRedeem(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_DOWN);\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return ISharesManager(sharesManager).allowance(owner, spender);\n    }\n}"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.16;\n\nimport \"./VaultStorage.sol\";\nimport \"./Interfaces/IVaultEvents.sol\";\nimport \"./Interfaces/IGovernance.sol\";\nimport \"./Interfaces/IStrategy.sol\";\nimport \"./Interfaces/ISharesManager.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n@title GOVERNANCE MANAGEMENT\n*/\n\ncontract Governance is AccessControl, VaultStorage, IVaultEvents, IGovernance, ReentrancyGuard {\n    // solhint-disable not-rely-on-time\n    // solhint-disable var-name-mixedcase\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    // solhint-disable max-line-length\n\n    error InactiveStrategy();\n    error ZeroValue();\n\n    constructor(\n        address _sharesManager\n    ) {\n        sharesManager = _sharesManager;\n    }\n\n    // @notice Used for governance to buy bad debt from the vault.\n    // @dev This should only ever be used in an emergency in place\n    //  of force revoking a strategy in order to not report a loss.\n    //  It allows the DEBT_PURCHASER role to buy the strategies debt\n    //  for an equal amount of `asset`. \n\n    // @param strategy The strategy to buy the debt for\n    // @param amount The amount of debt to buy from the vault.\n    function buyDebt(address strategy, uint256 amount) external override onlyRole(DEBT_PURCHASER) nonReentrant {\n        if (strategies[strategy].activation == 0) {\n            revert InactiveStrategy();\n        }\n\n        // Cache the current debt.\n        uint256 currentDebt = strategies[strategy].currentDebt;\n\n        if (currentDebt <= 0 || amount <= 0) {\n            revert ZeroValue();\n        }\n\n        if (amount > currentDebt) {\n            amount = currentDebt;\n        }\n\n        // We get the proportion of the debt that is being bought and\n        // transfer the equivalent shares. We assume this is being used\n        // due to strategy issues so won't rely on its conversion rates.\n        uint256 shares = IERC20(strategy).balanceOf(address(this)) * amount / currentDebt;\n\n        if (shares <= 0) {\n            revert ZeroValue();\n        }\n\n        ISharesManager(sharesManager).erc20SafeTransferFrom(sharesManager, msg.sender, address(this), amount);\n\n        // Lower strategy debt\n        strategies[strategy].currentDebt -= amount;\n        // lower total debt\n        totalDebtAmount -= amount;\n        // Increase total idle\n        totalIdleAmount += amount;\n\n        // Log debt change\n        emit DebtUpdated(strategy, currentDebt, currentDebt - amount);\n\n        // Transfer the strategies shares out\n        ISharesManager(sharesManager).erc20SafeTransfer(strategy, msg.sender, shares);\n\n        // Log the debt purchase\n        emit DebtPurchased(strategy, amount);\n    }\n\n    // EMERGENCY MANAGEMENT\n\n    // @notice Shutdown the vault.\n    function shutdownVault() external override onlyRole(EMERGENCY_MANAGER) {\n        if (shutdown == true) {\n            revert InactiveStrategy();\n        }\n\n        // Shutdown the vault.\n        shutdown = true;\n\n        // Set deposit limit to 0.\n        if (depositLimitModule != address(0)) {\n            depositLimitModule = address(0);\n            emit UpdateDepositLimitModule(address(0));\n        }\n\n        depositLimit = 0;\n        emit UpdateDepositLimit(0);\n\n        _grantRole(DEBT_MANAGER, msg.sender);\n        emit Shutdown();\n    }\n}\n    "
    },
    "contracts/Interfaces/IAccountant.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IAccountant {\n    function report(address strategy, uint256 gain, uint256 loss) external returns (uint256, uint256);\n}"
    },
    "contracts/Interfaces/IBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.16;\n\ninterface IBaseStrategy {\n    // solhint-disable ordering\n\n    function tokenizedStrategyAddress() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                            IMMUTABLE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function availableDepositLimit(\n        address _owner\n    ) external view returns (uint256);\n\n    function availableWithdrawLimit(\n        address _owner\n    ) external view returns (uint256);\n\n    function deployFunds(uint256 _assets) external;\n\n    function freeFunds(uint256 _amount) external;\n\n    function harvestAndReport() external returns (uint256);\n\n    function tendThis(uint256 _totalIdle) external;\n\n    function shutdownWithdraw(uint256 _amount) external;\n\n    function tendTrigger() external view returns (bool, bytes memory);\n}"
    },
    "contracts/Interfaces/IDepositLimitModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IDepositLimitModule {\n    function availableDepositLimit(address receiver) external view returns (uint256);\n}"
    },
    "contracts/Interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    // solhint-disable ordering\n    // solhint-disable max-line-length\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner, uint256 maxLoss, address[] memory strategies) external returns (uint256 assets);\n}"
    },
    "contracts/Interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IFactory {\n    function protocolFeeConfig() external view returns (uint16, address);\n}"
    },
    "contracts/Interfaces/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IGovernance {\n    function buyDebt(address strategy, uint256 amount) external;\n    function shutdownVault() external;\n}"
    },
    "contracts/Interfaces/ISetters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface ISetters {\n    function setAccountant(address newAccountant) external;\n    function setDefaultQueue(address[] calldata newDefaultQueue) external;\n    function setUseDefaultQueue(bool _useDefaultQueue) external;\n    function setDepositLimit(uint256 _depositLimit) external;\n    function setDepositLimitModule(address _depositLimitModule) external;\n    function setWithdrawLimitModule(address _withdrawLimitModule) external;\n    function setMinimumTotalIdle(uint256 _minimumTotalIdle) external;\n    function setProfitMaxUnlockTime(uint256 _newProfitMaxUnlockTime) external;\n}"
    },
    "contracts/Interfaces/ISharesManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"../VaultStructs.sol\";\nimport {IERC4626} from \"./IERC4626.sol\";\n\ninterface ISharesManager is IERC4626 {\n    // solhint-disable max-line-length\n    // solhint-disable ordering\n\n    function balanceOf(address addr) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function spendAllowance(address owner, address spender, uint256 amount) external;\n    function transfer(address sender, address receiver, uint256 amount) external;\n    function transferFrom(address sender, address receiver, uint256 amount) external returns (bool);\n    function approve(address owner, address spender, uint256 amount) external returns (bool);\n    function increaseAllowance(address owner, address spender, uint256 amount) external returns (bool);\n    function decreaseAllowance(address owner, address spender, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n    function burnShares(uint256 shares, address owner) external;\n    function unlockedShares() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function burnUnlockedShares() external;\n    function totalAssets() external view returns (uint256);\n    function convertToAssets(uint256 shares, Rounding rounding) external view returns (uint256);\n    function convertToShares(uint256 assets, Rounding rounding) external view returns (uint256);\n    function erc20SafeApprove(address token, address spender, uint256 amount) external;\n    function erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) external;\n    function erc20SafeTransfer(address token, address receiver, uint256 amount) external;\n    function issueShares(uint256 shares, address recipient) external;\n    function issueSharesForAmount(uint256 amount, address recipient) external returns (uint256);\n    function maxDeposit(address receiver) external view returns (uint256);\n    function maxWithdraw(address owner, uint256 _maxLoss, address[] memory _strategies) external returns (uint256);\n    function deposit(address sender, address recipient, uint256 assets) external returns (uint256);\n    function mint(address sender, address recipient, uint256 shares) external returns (uint256);\n    function assessShareOfUnrealisedLosses(address strategy, uint256 assetsNeeded) external view returns (uint256);\n    function withdrawFromStrategy(address strategy, uint256 assetsToWithdraw) external;\n    function calculateShareManagement(uint256 loss, uint256 totalFees, uint256 protocolFees) external returns (ShareManagement memory shareManagement);\n    function handleShareBurnsAndIssues(ShareManagement memory shares, FeeAssessment memory fees, uint256 gain, uint256 loss, address strategy) external returns (uint256 , uint256);\n    function manageUnlockingOfShares(uint256 previouslyLockedShares, uint256 newlyLockedShares) external;\n}"
    },
    "contracts/Interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IStrategy {\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);\n    function deposit(uint256 assets, address receiver) external returns (uint256);\n    function asset() external view returns (address);\n    function balanceOf(address owner) external view returns (uint256);\n    function maxDeposit(address receiver) external view returns (uint256);\n    function totalAssets() external view returns (uint256);\n    function convertToAssets(uint256 shares) external view returns (uint256);\n    function convertToShares(uint256 assets) external view returns (uint256);\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n    function maxRedeem(address owner) external view returns (uint256);\n}"
    },
    "contracts/Interfaces/IStrategyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IStrategyManager {\n    function addStrategy(address newStrategy) external;\n    function revokeStrategy(address strategy, bool force) external;\n    function updateMaxDebtForStrategy(address strategy, uint256 newMaxDebt) external;\n    function updateDebt(address strategy, uint256 targetDebt) external returns (uint256);\n    function processReport(address strategy) external returns (uint256, uint256);\n}"
    },
    "contracts/Interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"../VaultStructs.sol\";\n\ninterface IVault {\n    // solhint-disable ordering\n    \n    function setAccountant(address newAccountant) external;\n\n    function setDefaultQueue(address[] memory newDefaultQueue) external;\n\n    function setUseDefaultQueue(bool) external;\n\n    function setDepositLimit(uint256 depositLimit) external;\n\n    function setDepositLimitModule(\n        address newDepositLimitModule\n    ) external;\n\n    function setWithdrawLimitModule(\n        address newWithdrawLimitModule\n    ) external;\n\n    function setMinimumTotalIdle(uint256 minimumTotalIdle) external;\n\n    function setProfitMaxUnlockTime(\n        uint256 newProfitMaxUnlockTime\n    ) external;\n\n    function processReport(\n        address strategy\n    ) external returns (uint256, uint256);\n\n    function buyDebt(address strategy, uint256 amount) external;\n\n    function addStrategy(address newStrategy) external;\n\n    function revokeStrategy(address strategy) external;\n\n    function forceRevokeStrategy(address strategy) external;\n\n    function updateMaxDebtForStrategy(\n        address strategy,\n        uint256 newMaxDebt\n    ) external;\n\n    function updateDebt(\n        address strategy,\n        uint256 targetDebt\n    ) external returns (uint256);\n\n    function shutdownVault() external;\n\n    //// NON-STANDARD ERC-4626 FUNCTIONS \\\\\\\\\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory strategies\n    ) external returns (uint256);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory strategies\n    ) external returns (uint256);\n\n    //// NON-STANDARD ERC-20 FUNCTIONS \\\\\\\\\n\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (bool);\n\n    function maxWithdraw(\n        address owner,\n        uint256 maxLoss,\n        address[] memory strategies\n    ) external returns (uint256);\n\n    function maxRedeem(\n        address owner,\n        uint256 maxLoss,\n        address[] memory strategies\n    ) external returns (uint256);\n\n    function unlockedShares() external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function deposit(uint256 assets, address receiver) external returns (uint256);\n\n    function mint(uint256 shares, address receiver) external returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address receiver, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address receiver, uint256 amount) external returns (bool);\n\n    function balanceOf(address addr) external view returns (uint256);\n\n    function asset() external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function totalAssets() external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function maxDeposit(address receiver) external view returns (uint256);\n\n    function maxMint(address receiver) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}"
    },
    "contracts/Interfaces/IVaultEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL 3.0\n// Copyright Fathom 2023\n\npragma solidity ^0.8.16;\n\nimport \"../VaultStructs.sol\";\n\ninterface IVaultEvents {\n    // STRATEGY EVENTS\n    event StrategyChanged(address indexed strategy, StrategyChangeType changeType);\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 currentDebt,\n        uint256 protocolFees,\n        uint256 totalFees,\n        uint256 totalRefunds\n    );\n    // DEBT MANAGEMENT EVENTS\n    event DebtUpdated(\n        address indexed strategy,\n        uint256 currentDebt,\n        uint256 newDebt\n    );\n    // ROLE UPDATES\n    event RoleSet(address indexed account, bytes32 role);\n    event RoleStatusChanged(bytes32 indexed role, RoleStatusChange indexed status);\n    event UpdateRoleManager(address indexed roleManager);\n\n    event UpdateAccountant(address indexed accountant);\n    event UpdateDefaultQueue(address[] newDefaultQueue);\n    event UpdateUseDefaultQueue(bool useDefaultQueue);\n    event UpdatedMaxDebtForStrategy(\n        address indexed sender,\n        address indexed strategy,\n        uint256 newDebt\n    );\n    event UpdateDepositLimit(uint256 depositLimit);\n    event UpdateMinimumTotalIdle(uint256 minimumTotalIdle);\n    event UpdateProfitMaxUnlockTime(uint256 profitMaxUnlockTime);\n    event DebtPurchased(address indexed strategy, uint256 amount);\n    event Shutdown();\n\n    // STORAGE MANAGEMENT EVENTS\n    event UpdateDepositLimitModule(address indexed depositLimitModule);\n    event UpdateWithdrawLimitModule(address indexed withdrawLimitModule);\n}"
    },
    "contracts/Interfaces/IWithdrawLimitModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IWithdrawLimitModule {\n    function availableWithdrawLimit(address owner, uint256 maxLoss, address[] calldata strategies) external returns (uint256);\n}"
    },
    "contracts/Setters.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.16;\n\nimport \"./VaultStorage.sol\";\nimport \"./Interfaces/IVaultEvents.sol\";\nimport \"./Interfaces/ISetters.sol\";\nimport \"./Interfaces/ISharesManager.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n@title SETTERS CONTRACT\n*/\n\ncontract Setters is AccessControl, VaultStorage, IVaultEvents, ISetters {\n    // solhint-disable not-rely-on-time\n    // solhint-disable var-name-mixedcase\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    // solhint-disable max-line-length\n\n    error InactiveStrategy();\n    error StrategyIsShutdown();\n    error UsingModule();\n    error UsingDepositLimit();\n    error ProfitUnlockTimeTooLong();\n\n    constructor(\n        address _sharesManager\n    ) {\n        sharesManager = _sharesManager;\n    }\n\n    // @notice Set the new accountant address.\n    // @param new_accountant The new accountant address.\n    function setAccountant(address newAccountant) external override onlyRole(ACCOUNTANT_MANAGER) {\n        accountant = newAccountant;\n        emit UpdateAccountant(newAccountant);\n    }\n\n    // @notice Set the new default queue array.\n    // @dev Will check each strategy to make sure it is active.\n    // @param new_default_queue The new default queue array.\n    function setDefaultQueue(address[] calldata newDefaultQueue) external override onlyRole(QUEUE_MANAGER) {\n        // Make sure every strategy in the new queue is active.\n        for (uint256 i = 0; i < newDefaultQueue.length; i++) {\n            address strategy = newDefaultQueue[i];\n            if (strategies[strategy].activation == 0) {\n                revert InactiveStrategy();\n            }\n        }\n        // Save the new queue.\n        defaultQueue = newDefaultQueue;\n        emit UpdateDefaultQueue(newDefaultQueue);\n    }\n\n    // @notice Set a new value for `use_default_queue`.\n    // @dev If set `True` the default queue will always be\n    //  used no matter whats passed in.\n    // @param use_default_queue new value.\n    function setUseDefaultQueue(bool _useDefaultQueue) external override onlyRole(QUEUE_MANAGER) {\n        useDefaultQueue = _useDefaultQueue;\n        emit UpdateUseDefaultQueue(_useDefaultQueue);\n    }\n\n    // @notice Set the new deposit limit.\n    // @dev Can not be changed if a deposit_limit_module\n    //  is set or if shutdown.\n    // @param deposit_limit The new deposit limit.\n    function setDepositLimit(uint256 _depositLimit) external override onlyRole(DEPOSIT_LIMIT_MANAGER) {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        if (depositLimitModule != address(0)) {\n            revert UsingModule();\n        }\n        depositLimit = _depositLimit;\n        emit UpdateDepositLimit(_depositLimit);\n    }\n\n    // @notice Set a contract to handle the deposit limit.\n    // @dev The default `deposit_limit` will need to be set to\n    //  max uint256 since the module will override it.\n    // @param deposit_limit_module Address of the module.\n    function setDepositLimitModule(address _depositLimitModule) external override onlyRole(DEPOSIT_LIMIT_MANAGER) {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        if (depositLimit != type(uint256).max) {\n            revert UsingDepositLimit();\n        }\n        depositLimitModule = _depositLimitModule;\n        emit UpdateDepositLimitModule(_depositLimitModule);\n    }\n\n    // @notice Set a contract to handle the withdraw limit.\n    // @dev This will override the default `max_withdraw`.\n    // @param withdraw_limit_module Address of the module.\n    function setWithdrawLimitModule(address _withdrawLimitModule) external override onlyRole(WITHDRAW_LIMIT_MANAGER) {\n        withdrawLimitModule = _withdrawLimitModule;\n        emit UpdateWithdrawLimitModule(_withdrawLimitModule);\n    }\n\n    // @notice Set the new minimum total idle.\n    // @param minimum_total_idle The new minimum total idle.\n    function setMinimumTotalIdle(uint256 _minimumTotalIdle) external override onlyRole(MINIMUM_IDLE_MANAGER) {\n        minimumTotalIdle = _minimumTotalIdle;\n        emit UpdateMinimumTotalIdle(_minimumTotalIdle);\n    }\n\n    // @notice Set the new profit max unlock time.\n    // @dev The time is denominated in seconds and must be less than 1 year.\n    //  We only need to update locking period if setting to 0,\n    //  since the current period will use the old rate and on the next\n    //  report it will be reset with the new unlocking time.\n    \n    //  Setting to 0 will cause any currently locked profit to instantly\n    //  unlock and an immediate increase in the vaults Price Per Share.\n\n    // @param new_profit_max_unlock_time The new profit max unlock time.\n    function setProfitMaxUnlockTime(uint256 _newProfitMaxUnlockTime) external override onlyRole(PROFIT_UNLOCK_MANAGER) {\n        // Must be less than one year for report cycles\n        if (_newProfitMaxUnlockTime > ONE_YEAR) {\n            revert ProfitUnlockTimeTooLong();\n        }\n\n        // If setting to 0 we need to reset any locked values.\n        if (_newProfitMaxUnlockTime == 0) {\n            // Burn any shares the vault still has.\n            ISharesManager(sharesManager).burnShares(_balanceOf[address(this)], address(this));\n            // Reset unlocking variables to 0.\n            profitUnlockingRate = 0;\n            fullProfitUnlockDate = 0;\n        }\n        profitMaxUnlockTime = _newProfitMaxUnlockTime;\n        emit UpdateProfitMaxUnlockTime(_newProfitMaxUnlockTime);\n    }\n}\n    "
    },
    "contracts/SharesManager.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./VaultStorage.sol\";\nimport \"./Interfaces/IVaultEvents.sol\";\nimport \"./Interfaces/ISharesManager.sol\";\nimport \"./Interfaces/IStrategy.sol\";\nimport \"./Interfaces/IDepositLimitModule.sol\";\nimport \"./Interfaces/IWithdrawLimitModule.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n@title STRATEGY MANAGEMENT\n*/\n\ncontract SharesManager is VaultStorage, IVaultEvents, ReentrancyGuard, ISharesManager {\n    // solhint-disable not-rely-on-time\n    // solhint-disable var-name-mixedcase\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    // solhint-disable max-line-length\n    // solhint-disable ordering\n\n    using Math for uint256;\n\n    // IMMUTABLE\n    // Address of the underlying token used by the vault\n    IERC20 public immutable ASSET;\n    uint8 public immutable DECIMALS;\n\n    // ERC20 - name of the vault's token\n    string public override name;\n    // ERC20 - symbol of the vault's token\n    string public override symbol;\n\n    error ERC20InsufficientAllowance();\n    error InsufficientFunds();\n    error ZeroAddress();\n    error ERC20PermitExpired();\n    error ERC20PermitInvalidSignature();\n    error InsufficientShares();\n    error InactiveStrategy();\n    error StrategyIsShutdown();\n    error ExceedDepositLimit();\n    error ZeroValue();\n    error StrategyDebtIsLessThanAssetsNeeded();\n    error MaxLoss();\n    error InsufficientAssets();\n    error TooMuchLoss();\n    error InvalidAssetDecimals();\n\n    constructor(\n        address _asset,\n        uint8 _decimals,\n        string memory _name,\n        string memory _symbol\n    ) {\n        DECIMALS = _decimals;\n        if (DECIMALS >= 256) {\n            revert InvalidAssetDecimals();\n        }\n        ASSET = IERC20(_asset);\n        name = _name;\n        symbol = _symbol;\n    }\n\n\n    // SHARE MANAGEMENT\n    // ERC20\n\n    // @notice Get the balance of a user.\n    // @param addr The address to get the balance of.\n    // @return The balance of the user.\n    function balanceOf(address addr) external view override returns (uint256) {\n        if(addr == address(this)) {\n            return _balanceOf[addr] - _unlockedShares();\n        }\n        return _balanceOf[addr];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal {\n        // Unlimited approval does nothing (saves an SSTORE)\n        uint256 currentAllowance = _allowance[owner][spender];\n        if (currentAllowance < amount) {\n            revert ERC20InsufficientAllowance();\n        }\n        _approve(owner, spender, currentAllowance - amount);\n    }\n\n    function spendAllowance(address owner, address spender, uint256 amount) external override {\n        _spendAllowance(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address receiver, uint256 amount) internal {\n        uint256 currentBalance = _balanceOf[sender];\n        if (currentBalance < amount) {\n            revert InsufficientFunds();\n        }\n        if (sender == address(0) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _balanceOf[sender] = currentBalance - amount;\n        uint256 receiverBalance = _balanceOf[receiver];\n        _balanceOf[receiver] = receiverBalance + amount;\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function transfer(address sender, address receiver, uint256 amount) external override {\n        _transfer(sender, receiver, amount);\n    }\n\n    function transferFrom(address sender, address receiver, uint256 amount) external override returns (bool) {\n        _spendAllowance(sender, msg.sender, amount);\n        _transfer(sender, receiver, amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal returns (bool) {\n        if (owner == address(0) || spender == address(0)) {\n            revert ZeroAddress();\n        }\n        _allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n        return true;\n    }\n\n    function approve(address owner, address spender, uint256 amount) external override returns (bool) {\n        return _approve(owner, spender, amount);\n    }\n\n    function _increaseAllowance(address owner, address spender, uint256 amount) internal returns (bool) {\n        uint256 newAllowance = _allowance[owner][spender] + amount;\n        _approve(owner, spender, newAllowance);\n        return true;\n    }\n\n    function increaseAllowance(address owner, address spender, uint256 amount) external override returns (bool) {\n        return _increaseAllowance(owner, spender, amount);\n    }\n\n    function decreaseAllowance(address owner, address spender, uint256 amount) external override returns (bool) {\n        uint256 newAllowance = _allowance[owner][spender] - amount;\n        _approve(owner, spender, newAllowance);\n        return true;\n    }\n\n    function permit(\n        address owner, \n        address spender, \n        uint256 amount, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) external override returns (bool) {\n        if (owner == address(0)) {\n            revert ZeroAddress();\n        }\n        if (deadline < block.timestamp) {\n            revert ERC20PermitExpired();\n        }\n        uint256 nonce = nonces[owner];\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPE_HASH, owner, spender, amount, nonce, deadline));\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                structHash\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        if (recoveredAddress == address(0) || recoveredAddress != owner) {\n            revert ERC20PermitInvalidSignature();\n        }\n        \n        // Set the allowance to the specified amount\n        _approve(owner, spender, amount);\n\n        // Increase nonce for the owner\n        nonces[owner]++;\n\n        emit Approval(owner, spender, amount);\n        return true;\n    }\n\n    function _burnShares(uint256 shares, address owner) internal {\n        if (_balanceOf[owner] < shares) {\n            revert InsufficientShares();\n        }\n        _balanceOf[owner] -= shares;\n        totalSupplyAmount -= shares;\n        emit Transfer(owner, address(0), shares);\n    }\n\n    function burnShares(uint256 shares, address owner) external override {\n        _burnShares(shares, owner);\n    }\n\n    // Returns the amount of shares that have been unlocked.\n    // To avoid sudden pricePerShare spikes, profits must be processed \n    // through an unlocking period. The mechanism involves shares to be \n    // minted to the vault which are unlocked gradually over time. Shares \n    // that have been locked are gradually unlocked over profitMaxUnlockTime.\n    function _unlockedShares() internal view returns (uint256) {\n        uint256 _fullProfitUnlockDate = fullProfitUnlockDate;\n        uint256 currUnlockedShares = 0;\n        if (_fullProfitUnlockDate > block.timestamp) {\n            // If we have not fully unlocked, we need to calculate how much has been.\n            currUnlockedShares = profitUnlockingRate * (block.timestamp - lastProfitUpdate) / MAX_BPS_EXTENDED;\n        } else if (_fullProfitUnlockDate != 0) {\n            // All shares have been unlocked\n            currUnlockedShares = _balanceOf[address(this)];\n        }\n        return currUnlockedShares;\n    }\n\n    function unlockedShares() external override view returns (uint256) {\n        return _unlockedShares();\n    }\n\n    // Need to account for the shares issued to the vault that have unlocked.\n    function _totalSupply() internal view returns (uint256) {\n        return totalSupplyAmount - _unlockedShares();\n    }\n\n    function totalSupply() external override view returns (uint256) {\n        return _totalSupply();\n    }\n\n    // Burns shares that have been unlocked since last update. \n    // In case the full unlocking period has passed, it stops the unlocking.\n    function burnUnlockedShares() external override {\n        // Get the amount of shares that have unlocked\n        uint256 currUnlockedShares = _unlockedShares();\n        // IF 0 there's nothing to do.\n        if (currUnlockedShares == 0) return;\n        \n        // Only do an SSTORE if necessary\n        if (fullProfitUnlockDate > block.timestamp) {\n            lastProfitUpdate = block.timestamp;\n        }\n        \n        // Burn the shares unlocked.\n        _burnShares(currUnlockedShares, address(this));\n    }\n\n    // Total amount of assets that are in the vault and in the strategies.\n    function _totalAssets() internal view returns (uint256) {\n        return totalIdleAmount + totalDebtAmount;\n    }\n\n    function totalAssets() external override view returns (uint256) {\n        return _totalAssets();\n    }\n\n    // assets = shares * (total_assets / total_supply) --- (== price_per_share * shares)\n    function _convertToAssets(uint256 shares, Rounding rounding) internal view returns (uint256) {\n        if (shares == type(uint256).max || shares == 0) {\n            return shares;\n        }\n\n        uint256 currentTotalSupply = _totalSupply();\n        // if total_supply is 0, price_per_share is 1\n        if (currentTotalSupply == 0) {\n            return shares;\n        }\n\n        uint256 numerator = shares * _totalAssets();\n        uint256 amount = numerator / currentTotalSupply;\n        if (rounding == Rounding.ROUND_UP && numerator % currentTotalSupply != 0) {\n            amount += 1;\n        }\n\n        return amount;\n    }\n\n    function convertToAssets(uint256 shares, Rounding rounding) external override view returns (uint256) {\n        return _convertToAssets(shares, rounding);\n    }\n\n    // shares = amount * (total_supply / total_assets) --- (== amount / price_per_share)\n    function _convertToShares(uint256 assets, Rounding rounding) internal view returns (uint256) {\n        if (assets == type(uint256).max || assets == 0) {\n            return assets;\n        }\n\n        uint256 currentTotalSupply = _totalSupply();\n        uint256 currentTotalAssets = _totalAssets();\n        \n        if (currentTotalAssets == 0) {\n            // if total_assets and total_supply is 0, price_per_share is 1\n            if (currentTotalSupply == 0) {\n                return assets;\n            } else {\n                // Else if total_supply > 0 price_per_share is 0\n                return 0;\n            }\n        }\n\n        uint256 numerator = assets * currentTotalSupply;\n        uint256 shares = numerator / currentTotalAssets;\n        if (rounding == Rounding.ROUND_UP && numerator % currentTotalAssets != 0) {\n            shares += 1;\n        }\n\n        return shares;\n    }\n\n    function convertToShares(uint256 assets, Rounding rounding) external override view returns (uint256) {\n        return _convertToShares(assets, rounding);\n    }\n\n    // Used only to approve tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function erc20SafeApprove(address token, address spender, uint256 amount) external override {\n        if (token == address(0) || spender == address(0)) {\n            revert ZeroAddress();\n        }\n        require(IERC20(token).approve(spender, amount), \"approval failed\");\n    }\n\n    // Used only to transfer tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function _erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) internal {\n        if (token == address(0) || sender == address(0) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        require(IERC20(token).transferFrom(sender, receiver, amount), \"transfer failed\");\n    }\n\n    function erc20SafeTransferFrom(address token, address sender, address receiver, uint256 amount) external override {\n        _erc20SafeTransferFrom(token, sender, receiver, amount);\n    }\n\n    // Used only to send tokens that are not the type managed by this Vault.\n    // Used to handle non-compliant tokens like USDT\n    function _erc20SafeTransfer(address token, address receiver, uint256 amount) internal {\n        if (token == address(0) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        require(IERC20(token).transfer(receiver, amount), \"transfer failed\");\n    }\n\n    function erc20SafeTransfer(address token, address receiver, uint256 amount) external override {\n        _erc20SafeTransfer(token, receiver, amount);\n    }\n\n    function _issueShares(uint256 shares, address recipient) internal {\n        if (recipient == address(0)) {\n            revert ZeroAddress();\n        }\n        _balanceOf[recipient] += shares;\n        totalSupplyAmount += shares;\n        emit Transfer(address(0), recipient, shares);\n    }\n\n    function issueShares(uint256 shares, address recipient) external override {\n        _issueShares(shares, recipient);\n    }\n\n    // Issues shares that are worth 'amount' in the underlying token (asset).\n    // WARNING: this takes into account that any new assets have been summed \n    // to total_assets (otherwise pps will go down).\n    function _issueSharesForAmount(uint256 amount, address recipient) internal returns (uint256) {\n        if (recipient == address(0)) {\n            revert ZeroAddress();\n        }\n        uint256 currentTotalSupply = _totalSupply();\n        uint256 currentTotalAssets = _totalAssets();\n        uint256 newShares = 0;\n\n        // If no supply PPS = 1.\n        if (currentTotalSupply == 0) {\n            newShares = amount;\n        } else if (currentTotalAssets > amount) {\n            newShares = amount * currentTotalSupply / (currentTotalAssets - amount);\n        } else {\n            // If total_supply > 0 but amount = totalAssets we want to revert because\n            // after first deposit, getting here would mean that the rest of the shares\n            // would be diluted to a price_per_share of 0. Issuing shares would then mean\n            // either the new depositor or the previous depositors will loose money.\n            revert(\"amount too high\");\n        }\n\n        // We don't make the function revert\n        if (newShares == 0) {\n            return 0;\n        }\n\n        _issueShares(newShares, recipient);\n        return newShares;\n    }\n\n    function issueSharesForAmount(uint256 amount, address recipient) external override returns (uint256) {\n        return _issueSharesForAmount(amount, recipient);\n    }\n\n    // ERC4626\n\n    function _maxDeposit(address receiver) internal view returns (uint256) {\n        if (receiver == address(this) || receiver == address(0)) {\n            return 0;\n        }\n\n        // If there is a deposit limit module set use that.\n        address currentDepositLimitModule = depositLimitModule;\n        if (currentDepositLimitModule != address(0)) {\n            // Use the deposit limit module logic\n            return IDepositLimitModule(currentDepositLimitModule).availableDepositLimit(receiver);\n        }\n\n        // Else use the standard flow.\n        uint256 currentTotalAssets = _totalAssets();\n        uint256 currentDepositLimit = depositLimit;\n        if (currentTotalAssets >= currentDepositLimit) {\n            return 0;\n        }\n\n        return currentDepositLimit - currentTotalAssets;\n    }\n\n    function maxDeposit(address receiver) external override view returns (uint256) {\n        return _maxDeposit(receiver);\n    }\n\n    // @notice Preview the amount of shares that would be minted for a deposit.\n    // @param assets The amount of assets to deposit.\n    // @return The amount of shares that would be minted.\n    function previewDeposit(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_DOWN);\n    }\n\n    // @dev Returns the max amount of `asset` an `owner` can withdraw.\n    // This will do a full simulation of the withdraw in order to determine\n    // how much is currently liquid and if the `max_loss` would allow for the \n    // tx to not revert.\n    // This will track any expected loss to check if the tx will revert, but\n    // not account for it in the amount returned since it is unrealised and \n    // therefore will not be accounted for in the conversion rates.\n    // i.e. If we have 100 debt and 10 of unrealised loss, the max we can get\n    // out is 90, but a user of the vault will need to call withdraw with 100\n    // in order to get the full 90 out.\n    function _maxWithdraw(address owner, uint256 _maxLoss, address[] memory _strategies)\n        internal\n        returns (uint256)\n    {\n        // Get the max amount for the owner if fully liquid.\n        uint256 maxAssets = _convertToAssets(_balanceOf[owner], Rounding.ROUND_DOWN);\n\n        // If there is a withdraw limit module use that.\n        if (withdrawLimitModule != address(0)) {\n            uint256 moduleLimit = IWithdrawLimitModule(withdrawLimitModule).availableWithdrawLimit(owner, _maxLoss, _strategies);\n            if (moduleLimit < maxAssets) {\n                maxAssets = moduleLimit;\n            }\n            return maxAssets;\n        }\n\n        // See if we have enough idle to service the withdraw.\n        uint256 currentIdle = totalIdleAmount;\n        if (maxAssets > currentIdle) {\n            // Track how much we can pull.\n            uint256 have = currentIdle;\n            uint256 loss = 0;\n            \n            // Cache the default queue.\n            // If a custom queue was passed, and we don't force the default queue.\n            // Use the custom queue.\n            address[] memory currentStrategies = _strategies.length != 0 && !useDefaultQueue ? _strategies : defaultQueue;\n\n            for (uint256 i = 0; i < currentStrategies.length; i++) {\n                address strategy = currentStrategies[i];\n                // Can't use an invalid strategy.\n                if (strategies[strategy].activation == 0) {\n                    revert InactiveStrategy();\n                }\n\n                // Get the maximum amount the vault would withdraw from the strategy.\n                uint256 toWithdraw = Math.min(\n                    maxAssets - have, // What we still need for the full withdraw\n                    strategies[strategy].currentDebt // The current debt the strategy has.\n                    );\n\n                // Get any unrealised loss for the strategy.\n                uint256 unrealisedLoss = _assessShareOfUnrealisedLosses(strategy, toWithdraw);\n\n                // See if any limit is enforced by the strategy.\n                uint256 strategyLimit = IStrategy(strategy).convertToAssets(\n                    IStrategy(strategy).maxRedeem(address(this))\n                );\n\n                // Adjust accordingly if there is a max withdraw limit.\n                if (strategyLimit < toWithdraw - unrealisedLoss) {\n                    // lower unrealised loss to the proportional to the limit.\n                    unrealisedLoss = (unrealisedLoss * strategyLimit) / toWithdraw;\n                    // Still count the unrealised loss as withdrawable.\n                    toWithdraw = strategyLimit + unrealisedLoss;\n                }\n\n                // If 0 move on to the next strategy.\n                if (toWithdraw == 0) {\n                    continue;\n                }\n\n                // If there would be a loss with a non-maximum `max_loss` value.\n                if (unrealisedLoss > 0 && _maxLoss < MAX_BPS) {\n                    // Check if the loss is greater than the allowed range.\n                    if (loss + unrealisedLoss > (have + toWithdraw) * _maxLoss / MAX_BPS) {\n                        // If so use the amounts up till now.\n                        break;\n                    }\n                }\n\n                // Add to what we can pull.\n                have += toWithdraw;\n\n                // If we have all we need break.\n                if (have >= maxAssets) {\n                    break;\n                }\n\n                // Add any unrealised loss to the total\n                loss += unrealisedLoss;\n            }\n\n            // Update the max after going through the queue.\n            // In case we broke early or exhausted the queue.\n            maxAssets = have;\n        }\n\n        return maxAssets;\n    }\n\n    function maxWithdraw(address owner, uint256 _maxLoss, address[] memory _strategies)\n        external\n        override\n        returns (uint256)\n    {\n        return _maxWithdraw(owner, _maxLoss, _strategies);\n    }\n\n    // @notice Preview the amount of shares that would be redeemed for a withdraw.\n    // @param assets The amount of assets to withdraw.\n    // @return The amount of shares that would be redeemed.\n    function previewWithdraw(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_UP);\n    }\n\n    // @notice Withdraw an amount of asset to `receiver` burning `owner`s shares.\n    // @dev The default behavior is to not allow any loss.\n    // @param assets The amount of asset to withdraw.\n    // @param receiver The address to receive the assets.\n    // @param owner The address who's shares are being burnt.\n    // @param max_loss Optional amount of acceptable loss in Basis Points.\n    // @param strategies Optional array of strategies to withdraw from.\n    // @return The amount of shares actually burnt.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) external override returns (uint256) {\n        uint256 shares = _convertToShares(assets, Rounding.ROUND_UP);\n        _redeem(msg.sender, receiver, owner, assets, shares, maxLoss, _strategies);\n        return shares;\n    }\n\n    // @notice Get the maximum amount of shares that can be redeemed.\n    // @dev Complies to normal 4626 interface and takes custom params.\n    // @param owner The address that owns the shares.\n    // @param max_loss Custom max_loss if any.\n    // @param strategies Custom strategies queue if any.\n    // @return The maximum amount of shares that can be redeemed.\n    function maxRedeem(address owner, uint256 maxLoss, address[] memory _strategies) external override returns (uint256) {\n        uint256 maxWithdrawAmount = _maxWithdraw(owner, maxLoss, _strategies);\n        uint256 sharesEquivalent = _convertToShares(maxWithdrawAmount, Rounding.ROUND_UP);\n        return Math.min(sharesEquivalent, _balanceOf[owner]);\n    }\n\n    // @notice Preview the amount of assets that would be withdrawn for a redeem.\n    // @param shares The amount of shares to redeem.\n    // @return The amount of assets that would be withdrawn.\n    function previewRedeem(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_DOWN);\n    }\n\n    // Used for `deposit` calls to transfer the amount of `asset` to the vault, \n    // issue the corresponding shares to the `recipient` and update all needed \n    // vault accounting.\n    function _deposit(address sender, address recipient, uint256 assets) internal returns (uint256) {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        if (assets > _maxDeposit(recipient)) {\n            revert ExceedDepositLimit();\n        }\n        if (assets <= 0) {\n            revert ZeroValue();\n        }\n\n        // Transfer the tokens to the vault first.\n        ASSET.transferFrom(msg.sender, address(this), assets);\n        // Record the change in total assets.\n        totalIdleAmount += assets;\n\n        // Issue the corresponding shares for assets.\n        uint256 shares = _issueSharesForAmount(assets, recipient);\n        if (shares <= 0) {\n            revert ZeroValue();\n        }\n\n        emit Deposit(sender, recipient, assets, shares);\n        return shares;\n    }\n\n    function deposit(address sender, address recipient, uint256 assets) external override returns (uint256) {\n        return _deposit(sender, recipient, assets);\n    }\n\n    // @notice Get the maximum amount of shares that can be minted.\n    // @param receiver The address that will receive the shares.\n    // @return The maximum amount of shares that can be minted.\n    function maxMint(address receiver) external view override returns (uint256) {\n        uint256 maxDepositAmount = _maxDeposit(receiver);\n        return _convertToShares(maxDepositAmount, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Preview the amount of assets that would be deposited for a mint.\n    // @param shares The amount of shares to mint.\n    // @return The amount of assets that would be deposited.\n    function previewMint(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_UP);\n    }\n\n    // Used for `mint` calls to issue the corresponding shares to the `recipient`,\n    // transfer the amount of `asset` to the vault, and update all needed vault \n    // accounting.\n    function _mint(address sender, address recipient, uint256 shares) internal returns (uint256) {\n        if (shutdown == true) {\n            revert StrategyIsShutdown();\n        }\n        // Get corresponding amount of assets.\n        uint256 assets = _convertToAssets(shares, Rounding.ROUND_UP);\n\n        if (assets <= 0) {\n            revert ZeroValue();\n        }\n        if (assets > _maxDeposit(recipient)) {\n            revert ExceedDepositLimit();\n        }\n\n        // Transfer the tokens to the vault first.\n        ASSET.transferFrom(msg.sender, address(this), assets);\n        // Record the change in total assets.\n        totalIdleAmount += assets;\n\n        // Issue the corresponding shares for assets.\n        _issueShares(shares, recipient); // Assuming _issueShares is defined elsewhere\n\n        emit Deposit(sender, recipient, assets, shares);\n        return assets;\n    }\n\n    function mint(address sender, address recipient, uint256 shares) external override returns (uint256) {\n        return _mint(sender, recipient, shares);\n    }\n\n    // Returns the share of losses that a user would take if withdrawing from this strategy\n    // e.g. if the strategy has unrealised losses for 10% of its current debt and the user \n    // wants to withdraw 1000 tokens, the losses that he will take are 100 token\n    function _assessShareOfUnrealisedLosses(address strategy, uint256 assetsNeeded) internal view returns (uint256) {\n        // Minimum of how much debt the debt should be worth.\n        uint256 strategyCurrentDebt = strategies[strategy].currentDebt;\n        // The actual amount that the debt is currently worth.\n        uint256 vaultShares = IStrategy(strategy).balanceOf(address(this));\n        uint256 strategyAssets = IStrategy(strategy).convertToAssets(vaultShares);\n\n        // If no losses, return 0\n        if (strategyAssets >= strategyCurrentDebt || strategyCurrentDebt == 0) {\n            return 0;\n        }\n\n        // Users will withdraw assets_to_withdraw divided by loss ratio (strategy_assets / strategy_current_debt - 1),\n        // but will only receive assets_to_withdraw.\n        // NOTE: If there are unrealised losses, the user will take his share.\n        uint256 numerator = assetsNeeded * strategyAssets;\n        uint256 lossesUserShare = assetsNeeded - numerator / strategyCurrentDebt;\n\n        // Always round up.\n        if (numerator % strategyCurrentDebt != 0) {\n            lossesUserShare += 1;\n        }\n\n        return lossesUserShare;\n    }\n\n    function assessShareOfUnrealisedLosses(address strategy, uint256 assetsNeeded) external view override returns (uint256) {\n        // Assuming strategies mapping and _assess_share_of_unrealised_losses are defined\n        if (strategies[strategy].currentDebt < assetsNeeded) {\n            revert StrategyDebtIsLessThanAssetsNeeded();\n        }\n        return _assessShareOfUnrealisedLosses(strategy, assetsNeeded);\n    }\n\n    // This takes the amount denominated in asset and performs a {redeem}\n    // with the corresponding amount of shares.\n    // We use {redeem} to natively take on losses without additional non-4626 standard parameters.\n    function _withdrawFromStrategy(address strategy, uint256 assetsToWithdraw) internal {\n        // Need to get shares since we use redeem to be able to take on losses.\n        uint256 sharesToRedeem = Math.min(\n            IStrategy(strategy).previewWithdraw(assetsToWithdraw), // Use previewWithdraw since it should round up.\n            IStrategy(strategy).balanceOf(address(this)) // And check against our actual balance.\n        );\n\n        // Redeem the shares.\n        IStrategy(strategy).redeem(sharesToRedeem, address(this), address(this));\n    }\n\n    function withdrawFromStrategy(address strategy, uint256 assetsToWithdraw) external override {\n        _withdrawFromStrategy(strategy, assetsToWithdraw);\n    }\n\n    // This will attempt to free up the full amount of assets equivalent to\n    // `shares_to_burn` and transfer them to the `receiver`. If the vault does\n    // not have enough idle funds it will go through any strategies provided by\n    // either the withdrawer or the queue_manager to free up enough funds to \n    // service the request.\n    // The vault will attempt to account for any unrealized losses taken on from\n    // strategies since their respective last reports.\n    // Any losses realized during the withdraw from a strategy will be passed on\n    // to the user that is redeeming their vault shares.\n    function _redeem(\n        address sender,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 sharesToBurn,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) internal returns (uint256) {\n        _validateRedeem(receiver, owner, sharesToBurn, maxLoss);\n        _handleAllowance(owner, sender, sharesToBurn);\n        (uint256 requestedAssets, uint256 currTotalIdle) = _withdrawAssets(assets, _strategies);\n        _finalizeRedeem(receiver, owner, sharesToBurn, assets, requestedAssets, currTotalIdle, maxLoss);\n        \n        emit Withdraw(sender, receiver, owner, requestedAssets, sharesToBurn);\n        return requestedAssets;\n    }\n\n    // Validates the state and inputs for the redeem operation.\n    function _validateRedeem(\n        address receiver,\n        address owner,\n        uint256 sharesToBurn,\n        uint256 maxLoss\n    ) internal view {\n        if (receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        if (maxLoss > MAX_BPS) {\n            revert MaxLoss();\n        }\n        if (sharesToBurn <= 0) {\n            revert ZeroValue();\n        }\n        if (_balanceOf[owner] < sharesToBurn) {\n            revert InsufficientShares();\n        }\n    }\n\n    // Handles the allowance check and spending.\n    function _handleAllowance(address owner, address sender, uint256 sharesToBurn) internal {\n        if (sender != owner) {\n            _spendAllowance(owner, sender, sharesToBurn);\n        }\n    }\n\n    // Withdraws assets from strategies as needed and handles unrealized losses.\n    function _withdrawAssets(uint256 assets, address[] memory _strategies) internal returns (uint256, uint256) {\n        // Initialize the state struct\n        WithdrawalState memory state = WithdrawalState({\n            requestedAssets: assets,\n            currTotalIdle: totalIdleAmount,\n            currTotalDebt: totalDebtAmount,\n            assetsNeeded: 0,\n            previousBalance: ASSET.balanceOf(address(this)),\n            unrealisedLossesShare: 0\n        });\n\n        // If there are not enough assets in the Vault contract, we try to free\n        // funds from strategies.\n        if (state.requestedAssets > state.currTotalIdle) {\n            // Cache the default queue.\n            address[] memory currentStrategies = _strategies.length != 0 && !useDefaultQueue ? _strategies : defaultQueue;\n\n            // Withdraw from strategies only what idle doesn't cover.\n            // `assetsNeeded` is the total amount we need to fill the request.\n            state.assetsNeeded = state.requestedAssets - state.currTotalIdle;\n\n            // Assuming _strategies is an array of addresses representing the strategies\n            for (uint256 i = 0; i < currentStrategies.length; i++) {\n                address strategy = currentStrategies[i];\n                \n                // Make sure we have a valid strategy.\n                if (strategies[strategy].activation == 0) {\n                    revert InactiveStrategy();\n                }\n\n                // How much should the strategy have.\n                uint256 currentDebt = strategies[strategy].currentDebt;\n\n                // What is the max amount to withdraw from this strategy.\n                uint256 assetsToWithdraw = Math.min(state.assetsNeeded, currentDebt);\n\n                // Cache max_withdraw now for use if unrealized loss > 0\n                // Use maxRedeem and convert since we use redeem.\n                uint256 currMaxWithdraw = IStrategy(strategy).convertToAssets(\n                    IStrategy(strategy).maxRedeem(address(this))\n                );\n\n                // CHECK FOR UNREALIZED LOSSES\n                // If unrealised losses > 0, then the user will take the proportional share \n                // and realize it (required to avoid users withdrawing from lossy strategies).\n                // NOTE: strategies need to manage the fact that realising part of the loss can \n                // mean the realisation of 100% of the loss!! (i.e. if for withdrawing 10% of the\n                // strategy it needs to unwind the whole position, generated losses might be bigger)\n                uint256 unrealisedLossesShare = _assessShareOfUnrealisedLosses(strategy, assetsToWithdraw);\n                if (unrealisedLossesShare > 0) {\n                    // If max withdraw is limiting the amount to pull, we need to adjust the portion of \n                    // the unrealized loss the user should take.\n                    if (currMaxWithdraw < assetsToWithdraw - unrealisedLossesShare) {\n                        // How much would we want to withdraw\n                        uint256 wanted = assetsToWithdraw - unrealisedLossesShare;\n                        // Get the proportion of unrealised comparing what we want vs. what we can get\n                        unrealisedLossesShare = unrealisedLossesShare * currMaxWithdraw / wanted;\n                        // Adjust assetsToWithdraw so all future calculations work correctly\n                        assetsToWithdraw = currMaxWithdraw + unrealisedLossesShare;\n                    }\n                    \n                    // User now \"needs\" less assets to be unlocked (as he took some as losses)\n                    assetsToWithdraw -= unrealisedLossesShare;\n                    state.requestedAssets -= unrealisedLossesShare;\n                    // NOTE: done here instead of waiting for regular update of these values \n                    // because it's a rare case (so we can save minor amounts of gas)\n                    state.assetsNeeded -= unrealisedLossesShare;\n                    state.currTotalDebt -= unrealisedLossesShare;\n\n                    // If max withdraw is 0 and unrealised loss is still > 0 then the strategy likely\n                    // realized a 100% loss and we will need to realize that loss before moving on.\n                    if (currMaxWithdraw == 0 && unrealisedLossesShare > 0) {\n                        // Adjust the strategy debt accordingly.\n                        uint256 newDebt = currentDebt - unrealisedLossesShare;\n\n                        // Update strategies storage\n                        strategies[strategy].currentDebt = newDebt;\n\n                        // Log the debt update\n                        emit DebtUpdated(strategy, currentDebt, newDebt);\n                    }\n                }\n\n                // Adjust based on the max withdraw of the strategy.\n                assetsToWithdraw = Math.min(assetsToWithdraw, currMaxWithdraw);\n\n                // Can't withdraw 0.\n                if (assetsToWithdraw == 0) {\n                    continue;\n                }\n\n                // WITHDRAW FROM STRATEGY\n                _withdrawFromStrategy(strategy, assetsToWithdraw);\n                uint256 postBalance = ASSET.balanceOf(address(this));\n                \n                // Always check withdrawn against the real amounts.\n                uint256 withdrawn = postBalance - state.previousBalance;\n                uint256 loss = 0;\n                // Check if we redeemed too much.\n                if (withdrawn > assetsToWithdraw) {\n                    // Make sure we don't underflow in debt updates.\n                    if (withdrawn > currentDebt) {\n                        // Can't withdraw more than our debt.\n                        assetsToWithdraw = currentDebt;\n                    } else {\n                        assetsToWithdraw += withdrawn - assetsToWithdraw;\n                    }\n                // If we have not received what we expected, we consider the difference a loss.\n                } else if (withdrawn < assetsToWithdraw) {\n                    loss = assetsToWithdraw - withdrawn;\n                }\n\n                // NOTE: strategy's debt decreases by the full amount but the total idle increases \n                // by the actual amount only (as the difference is considered lost).\n                state.currTotalIdle += assetsToWithdraw - loss;\n                state.requestedAssets -= loss;\n                state.currTotalDebt -= assetsToWithdraw;\n\n                // Vault will reduce debt because the unrealised loss has been taken by user\n                uint256 _newDebt = currentDebt - (assetsToWithdraw + unrealisedLossesShare);\n\n                // Update strategies storage\n                strategies[strategy].currentDebt = _newDebt;\n                // Log the debt update\n                emit DebtUpdated(strategy, currentDebt, _newDebt);\n\n                // Break if we have enough total idle to serve initial request.\n                if (state.requestedAssets <= state.currTotalIdle) {\n                    break;\n                }\n\n                // We update the previous_balance variable here to save gas in next iteration.\n                state.previousBalance = postBalance;\n\n                // Reduce what we still need. Safe to use assets_to_withdraw \n                // here since it has been checked against requested_assets\n                state.assetsNeeded -= assetsToWithdraw;\n            }\n\n            // If we exhaust the queue and still have insufficient total idle, revert.\n            if (state.currTotalIdle < state.requestedAssets) {\n                revert InsufficientAssets();\n            }\n\n            // Commit memory to storage.\n            totalDebtAmount = state.currTotalDebt;\n        }\n\n        return (state.requestedAssets, state.currTotalIdle);\n    }\n\n    // Finalizes the redeem operation by burning shares and transferring assets.\n    function _finalizeRedeem(\n        address receiver,\n        address owner,\n        uint256 sharesToBurn,\n        uint256 assets,\n        uint256 requestedAssets,\n        uint256 currTotalIdle,\n        uint256 maxLoss\n    ) internal {\n        // Check if there is a loss and a non-default value was set.\n        if (assets > requestedAssets && maxLoss < MAX_BPS) {\n            // Assure the loss is within the allowed range.\n            if (assets - requestedAssets > assets * maxLoss / MAX_BPS) {\n                revert TooMuchLoss();\n            }\n        }\n\n        // First burn the corresponding shares from the redeemer.\n        _burnShares(sharesToBurn, owner);\n        // Commit memory to storage.\n        totalIdleAmount = currTotalIdle - requestedAssets;\n        // Transfer the requested amount to the receiver.\n        _erc20SafeTransfer(address(ASSET), receiver, requestedAssets);\n    }\n\n    // ## ERC20+4626 compatibility\n\n    // @notice Get the address of the asset.\n    // @return The address of the asset.\n    function asset() external view override returns (address) {\n        return address(ASSET);\n    }\n\n    // @notice Get the number of decimals of the asset/share.\n    // @return The number of decimals of the asset/share.\n    function decimals() external view override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    // @notice Approve an address to spend the vault's shares.\n    // @param spender The address to approve.\n    // @param amount The amount of shares to approve.\n    // @return True if the approval was successful.\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        return _approve(msg.sender, spender, amount);\n    }\n\n    // @notice Convert an amount of shares to assets.\n    // @param shares The amount of shares to convert.\n    // @return The amount of assets.\n    function convertToAssets(uint256 shares) external view override returns (uint256) {\n        return _convertToAssets(shares, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Convert an amount of assets to shares.\n    // @param assets The amount of assets to convert.\n    // @return The amount of shares.\n    function convertToShares(uint256 assets) external view override returns (uint256) {\n        return _convertToShares(assets, Rounding.ROUND_DOWN);\n    }\n\n    // @notice Deposit assets into the vault.\n    // @param assets The amount of assets to deposit.\n    // @param receiver The address to receive the shares.\n    // @return The amount of shares minted.\n    function deposit(uint256 assets, address receiver) external override nonReentrant returns (uint256) {\n        return _deposit(msg.sender, receiver, assets);\n    }\n\n    // @notice Mint shares for the receiver.\n    // @param shares The amount of shares to mint.\n    // @param receiver The address to receive the shares.\n    // @return The amount of assets deposited.\n    function mint(uint256 shares, address receiver) external override nonReentrant returns (uint256) {\n        return _mint(msg.sender, receiver, shares);\n    }\n\n    // @notice Transfer shares to a receiver.\n    // @param receiver The address to transfer shares to.\n    // @param amount The amount of shares to transfer.\n    // @return True if the transfer was successful.\n    function transfer(address receiver, uint256 amount) external override returns (bool) {\n        if (receiver == address(this) || receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    // @notice Redeems an amount of shares of `owners` shares sending funds to `receiver`.\n    // @dev The default behavior is to allow losses to be realized.\n    // @param shares The amount of shares to burn.\n    // @param receiver The address to receive the assets.\n    // @param owner The address who's shares are being burnt.\n    // @param max_loss Optional amount of acceptable loss in Basis Points.\n    // @param strategies Optional array of strategies to withdraw from.\n    // @return The amount of assets actually withdrawn.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 maxLoss,\n        address[] memory _strategies\n    ) external override nonReentrant returns (uint256) {\n        uint256 assets = _convertToAssets(shares, Rounding.ROUND_DOWN);\n        // Always return the actual amount of assets withdrawn.\n        return _redeem(msg.sender, receiver, owner, assets, shares, maxLoss, _strategies);\n    }\n\n    // Calculate share management based on gains, losses, and fees.\n    function calculateShareManagement(uint256 loss, uint256 totalFees, uint256 protocolFees) external override view returns (ShareManagement memory) {\n        // `shares_to_burn` is derived from amounts that would reduce the vaults PPS.\n        // NOTE: this needs to be done before any pps changes\n        ShareManagement memory shares;\n\n        // Only need to burn shares if there is a loss or fees.\n        if (loss + totalFees > 0) {\n            // The amount of shares we will want to burn to offset losses and fees.\n            shares.sharesToBurn += _convertToShares(loss + totalFees, Rounding.ROUND_UP);\n\n            // Vault calculates the amount of shares to mint as fees before changing totalAssets / totalSupply.\n            if (totalFees > 0) {\n                // Accountant fees are total fees - protocol fees.\n                shares.accountantFeesShares = _convertToShares(totalFees - protocolFees, Rounding.ROUND_DOWN);\n                if (protocolFees > 0) {\n                    shares.protocolFeesShares = _convertToShares(protocolFees, Rounding.ROUND_DOWN);\n                }\n            }\n        }\n\n        return shares;\n    }\n\n    // Handle the burning and issuing of shares based on the strategy's report.\n    function handleShareBurnsAndIssues(\n        ShareManagement memory shares, \n        FeeAssessment memory fees, \n        uint256 gain, \n        uint256 loss, \n        address strategy\n    ) external override returns (uint256 previouslyLockedShares, uint256 newlyLockedShares) {\n        // Shares to lock is any amounts that would otherwise increase the vaults PPS.\n        uint256 _newlyLockedShares;\n        if (fees.totalRefunds > 0) {\n            // Make sure we have enough approval and enough asset to pull.\n            fees.totalRefunds = Math.min(fees.totalRefunds, Math.min(ISharesManager(sharesManager).balanceOf(accountant), ISharesManager(sharesManager).allowance(accountant, address(this))));\n            // Transfer the refunded amount of asset to the vault.\n            _erc20SafeTransferFrom(sharesManager, accountant, address(this), fees.totalRefunds);\n            // Update storage to increase total assets.\n            totalIdleAmount += fees.totalRefunds;\n        }\n\n        // Record any reported gains.\n        if (gain > 0) {\n            // NOTE: this will increase total_assets\n            strategies[strategy].currentDebt += gain;\n            totalDebtAmount += gain;\n        }\n\n        // Mint anything we are locking to the vault.\n        if (gain + fees.totalRefunds > 0 && profitMaxUnlockTime != 0) {\n            _newlyLockedShares = _issueSharesForAmount(gain + fees.totalRefunds, address(this));\n        }\n\n        // Strategy is reporting a loss\n        if (loss > 0) {\n            strategies[strategy].currentDebt -= loss;\n            totalDebtAmount -= loss;\n        }\n\n        // NOTE: should be precise (no new unlocked shares due to above's burn of shares)\n        // newly_locked_shares have already been minted / transferred to the vault, so they need to be subtracted\n        // no risk of underflow because they have just been minted.\n        uint256 _previouslyLockedShares = _balanceOf[address(this)] - _newlyLockedShares;\n\n        // Now that pps has updated, we can burn the shares we intended to burn as a result of losses/fees.\n        // NOTE: If a value reduction (losses / fees) has occurred, prioritize burning locked profit to avoid\n        // negative impact on price per share. Price per share is reduced only if losses exceed locked value.\n        if (shares.sharesToBurn > 0) {\n            // Cant burn more than the vault owns.\n            shares.sharesToBurn = Math.min(shares.sharesToBurn, _previouslyLockedShares + _newlyLockedShares);\n            _burnShares(shares.sharesToBurn, address(this));\n\n            // We burn first the newly locked shares, then the previously locked shares.\n            uint256 sharesNotToLock = Math.min(shares.sharesToBurn, _newlyLockedShares);\n            // Reduce the amounts to lock by how much we burned\n            _newlyLockedShares -= sharesNotToLock;\n            _previouslyLockedShares -= (shares.sharesToBurn - sharesNotToLock);\n        }\n\n        // Issue shares for fees that were calculated above if applicable.\n        if (shares.accountantFeesShares > 0) {\n            _issueShares(shares.accountantFeesShares, accountant);\n        }\n\n        if (shares.protocolFeesShares > 0) {\n            _issueShares(shares.protocolFeesShares, fees.protocolFeeRecipient);\n        }\n\n        return (_previouslyLockedShares, _newlyLockedShares);\n    }\n\n    // Manage the unlocking of shares over time based on the vault's configuration.\n    function manageUnlockingOfShares(uint256 previouslyLockedShares, uint256 newlyLockedShares) external override {\n        // Update unlocking rate and time to fully unlocked.\n        uint256 totalLockedShares = previouslyLockedShares + newlyLockedShares;\n        if (totalLockedShares > 0) {\n            uint256 previouslyLockedTime = 0;\n            // Check if we need to account for shares still unlocking.\n            if (fullProfitUnlockDate > block.timestamp) {\n                // There will only be previously locked shares if time remains.\n                // We calculate this here since it will not occur every time we lock shares.\n                previouslyLockedTime = previouslyLockedShares * (fullProfitUnlockDate - block.timestamp);\n            }\n\n            // newProfitLockingPeriod is a weighted average between the remaining time of the previously locked shares and the profitMaxUnlockTime\n            uint256 newProfitLockingPeriod = (previouslyLockedTime + newlyLockedShares * profitMaxUnlockTime) / totalLockedShares;\n            // Calculate how many shares unlock per second.\n            profitUnlockingRate = totalLockedShares * MAX_BPS_EXTENDED / newProfitLockingPeriod;\n            // Calculate how long until the full amount of shares is unlocked.\n            fullProfitUnlockDate = block.timestamp + newProfitLockingPeriod;\n            // Update the last profitable report timestamp.\n            lastProfitUpdate = block.timestamp;\n        } else {\n            // NOTE: only setting this to 0 will turn in the desired effect, no need \n            // to update last_profit_update or full_profit_unlock_date\n            profitUnlockingRate = 0;\n        }\n    }\n}\n    "
    },
    "contracts/StrategyManager.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.16;\n\nimport \"./VaultStorage.sol\";\nimport \"./Interfaces/IVaultEvents.sol\";\nimport \"./Interfaces/IStrategyManager.sol\";\nimport \"./Interfaces/IStrategy.sol\";\nimport \"./Interfaces/ISharesManager.sol\";\nimport \"./Interfaces/IAccountant.sol\";\nimport \"./Interfaces/IFactory.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n@title STRATEGY MANAGEMENT\n*/\n\ncontract StrategyManager is VaultStorage, IVaultEvents, IStrategyManager {\n    // solhint-disable not-rely-on-time\n    // solhint-disable var-name-mixedcase\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    // solhint-disable max-line-length\n    // solhint-disable ordering\n\n    using Math for uint256;\n\n    // IMMUTABLE\n    // Address of the underlying token used by the vault\n    IERC20 public immutable ASSET;\n    // Factory address\n    address public immutable FACTORY;\n\n    error ZeroAddress();\n    error InactiveStrategy();\n    error InvalidAsset();\n    error StrategyAlreadyActive();\n    error StrategyHasDebt();\n    error DebtDidntChange();\n    error ZeroValue();\n    error StrategyHasUnrealisedLosses();\n    error DebtHigherThanMaxDebt();\n    error InsufficientFunds();\n    error StrategyDebtIsLessThanAssetsNeeded();\n\n\n    constructor(\n        address _asset,\n        address _sharesManager\n    ) {\n        ASSET = IERC20(_asset);\n        FACTORY = msg.sender;\n        sharesManager = _sharesManager;\n    }\n\n\n    function addStrategy(address newStrategy) external override {\n        if (newStrategy == address(0) || newStrategy == address(this)) {\n            revert ZeroAddress();\n        }\n        if (IStrategy(newStrategy).asset() != address(ASSET)) {\n            revert InvalidAsset();\n        }\n        if (strategies[newStrategy].activation != 0) {\n            revert StrategyAlreadyActive();\n        }\n\n        // Add the new strategy to the mapping.\n        strategies[newStrategy] = StrategyParams({\n            activation: block.timestamp,\n            lastReport: block.timestamp,\n            currentDebt: 0,\n            maxDebt: 0\n        });\n\n        // If the default queue has space, add the strategy.\n        uint256 defaultQueueLength = defaultQueue.length;\n        if (defaultQueueLength < MAX_QUEUE) {\n            defaultQueue.push(newStrategy);\n        }\n        \n        emit StrategyChanged(newStrategy, StrategyChangeType.ADDED);\n    }\n\n    function revokeStrategy(address strategy, bool force) external override {\n        if (strategies[strategy].activation == 0) {\n            revert InactiveStrategy();\n        }\n        \n        // If force revoking a strategy, it will cause a loss.\n        uint256 loss = 0;\n        if (strategies[strategy].currentDebt != 0 && !force) {\n            revert StrategyHasDebt();\n        }\n\n        // Vault realizes the full loss of outstanding debt.\n        loss = strategies[strategy].currentDebt;\n        // Adjust total vault debt.\n        totalDebtAmount -= loss;\n        \n        emit StrategyReported(strategy, 0, loss, 0, 0, 0, 0);\n\n        // Set strategy params all back to 0 (WARNING: it can be re-added).\n        strategies[strategy] = StrategyParams({\n            activation: 0,\n            lastReport: 0,\n            currentDebt: 0,\n            maxDebt: 0\n        });\n\n        // Remove strategy if it is in the default queue.\n        address[] memory newQueue;\n        if (defaultQueue.length > 0) {\n            for (uint256 i = 0; i < defaultQueue.length; i++) {\n                address _strategy = defaultQueue[i];\n                // Add all strategies to the new queue besides the one revoked.\n                if (_strategy != strategy) {\n                    newQueue[i] = _strategy;\n                }\n            }\n        }\n\n        // Set the default queue to our updated queue.\n        defaultQueue = newQueue;\n\n        emit StrategyChanged(strategy, StrategyChangeType.REVOKED);\n    }\n\n    function updateMaxDebtForStrategy(address strategy, uint256 newMaxDebt) external override {\n        if (strategies[strategy].activation == 0) {\n            revert InactiveStrategy();\n        }\n        strategies[strategy].maxDebt = newMaxDebt;\n        emit UpdatedMaxDebtForStrategy(msg.sender, strategy, newMaxDebt);\n    }\n\n    function updateDebt(address strategy, uint256 targetDebt) external override returns (uint256) {\n        // How much we want the strategy to have.\n        uint256 newDebt = targetDebt;\n        // How much the strategy currently has.\n        uint256 currentDebt = strategies[strategy].currentDebt;\n\n        // If the vault is shutdown we can only pull funds.\n        if (shutdown == true) {\n            newDebt = 0;\n        }\n\n        if (newDebt == currentDebt) {\n            revert DebtDidntChange();\n        }\n\n        if (currentDebt > newDebt) {\n            // Reduce debt\n            uint256 assetsToWithdraw = currentDebt - newDebt;\n\n            // Respect minimum total idle in vault\n            if (totalIdleAmount + assetsToWithdraw < minimumTotalIdle) {\n                assetsToWithdraw = minimumTotalIdle - totalIdleAmount;\n                // Cant withdraw more than the strategy has.\n                if (assetsToWithdraw > currentDebt) {\n                    assetsToWithdraw = currentDebt;\n                }\n            }\n\n            // Check how much we are able to withdraw.\n            // Use maxRedeem and convert since we use redeem.\n            uint256 withdrawable = IStrategy(strategy).convertToAssets(IStrategy(strategy).maxRedeem(address(this)));\n\n            if (withdrawable <= 0) {\n                revert ZeroValue();\n            }\n\n            // If insufficient withdrawable, withdraw what we can.\n            if (withdrawable < assetsToWithdraw) {\n                assetsToWithdraw = withdrawable;\n            }\n\n            // If there are unrealised losses we don't let the vault reduce its debt until there is a new report\n            uint256 unrealisedLossesShare = ISharesManager(sharesManager).assessShareOfUnrealisedLosses(strategy, assetsToWithdraw);\n            if (unrealisedLossesShare != 0) {\n                revert StrategyHasUnrealisedLosses();\n            }\n\n            // Always check the actual amount withdrawn.\n            uint256 preBalance = ASSET.balanceOf(address(this));\n            ISharesManager(sharesManager).withdrawFromStrategy(strategy, assetsToWithdraw);\n            uint256 postBalance = ASSET.balanceOf(address(this));\n\n            // making sure we are changing idle according to the real result no matter what. \n            // We pull funds with {redeem} so there can be losses or rounding differences.\n            uint256 withdrawn = Math.min(postBalance - preBalance, currentDebt);\n\n            // If we got too much make sure not to increase PPS.\n            if (withdrawn > assetsToWithdraw) {\n                assetsToWithdraw = withdrawn;\n            }\n\n            // Update storage.\n            totalIdleAmount += withdrawn; // actual amount we got.\n            // Amount we tried to withdraw in case of losses\n            totalDebtAmount -= assetsToWithdraw;\n\n            newDebt = currentDebt - assetsToWithdraw;\n        } else {\n            // We are increasing the strategies debt\n\n            // Revert if target_debt cannot be achieved due to configured max_debt for given strategy\n            if (newDebt > strategies[strategy].maxDebt) {\n                revert DebtHigherThanMaxDebt();\n            }\n\n            // Vault is increasing debt with the strategy by sending more funds.\n            uint256 currentMaxDeposit = IStrategy(strategy).maxDeposit(address(this));\n            if (currentMaxDeposit <= 0) {\n                revert ZeroValue();\n            }\n\n            // Deposit the difference between desired and current.\n            uint256 assetsToDeposit = newDebt - currentDebt;\n            if (assetsToDeposit > currentMaxDeposit) {\n                // Deposit as much as possible.\n                assetsToDeposit = currentMaxDeposit;\n            }\n\n            uint256 availableIdle = totalIdleAmount - minimumTotalIdle;\n\n            // If insufficient funds to deposit, transfer only what is free.\n            if (assetsToDeposit > availableIdle) {\n                assetsToDeposit = availableIdle;\n            }\n\n            // Can't Deposit 0.\n            if (assetsToDeposit > 0) {\n                // Approve the strategy to pull only what we are giving it.\n                ISharesManager(sharesManager).erc20SafeApprove(address(ASSET), strategy, assetsToDeposit);\n\n                // Always update based on actual amounts deposited.\n                uint256 preBalance = ASSET.balanceOf(address(this));\n                IStrategy(strategy).deposit(assetsToDeposit, address(this));\n                uint256 postBalance = ASSET.balanceOf(address(this));\n\n                // Make sure our approval is always back to 0.\n                ISharesManager(sharesManager).erc20SafeApprove(address(ASSET), strategy, 0);\n\n                // Making sure we are changing according to the real result no \n                // matter what. This will spend more gas but makes it more robust.\n                assetsToDeposit = preBalance - postBalance;\n\n                // Update storage.\n                totalIdleAmount -= assetsToDeposit;\n                totalDebtAmount += assetsToDeposit;\n\n                newDebt = currentDebt + assetsToDeposit;\n            }\n        }\n\n        // Commit memory to storage.\n        strategies[strategy].currentDebt = newDebt;\n\n        emit DebtUpdated(strategy, currentDebt, newDebt);\n        return newDebt;\n    }\n\n    // Processing a report means comparing the debt that the strategy has taken \n    // with the current amount of funds it is reporting. If the strategy owes \n    // less than it currently has, it means it has had a profit, else (assets < debt) \n    // it has had a loss.\n\n    // Different strategies might choose different reporting strategies: pessimistic, \n    // only realised P&L, ... The best way to report depends on the strategy.\n\n    // The profit will be distributed following a smooth curve over the vaults \n    // profit_max_unlock_time seconds. Losses will be taken immediately, first from the \n    // profit buffer (avoiding an impact in pps), then will reduce pps.\n\n    // Any applicable fees are charged and distributed during the report as well\n    // to the specified recipients.\n    function processReport(address strategy) external override returns (uint256, uint256) {\n        // Make sure we have a valid strategy.\n        if (strategies[strategy].activation == 0) {\n            revert InactiveStrategy();\n        }\n\n        // Burn shares that have been unlocked since the last update\n        ISharesManager(sharesManager).burnUnlockedShares();\n\n        (uint256 gain, uint256 loss) = _assessProfitAndLoss(strategy);\n\n        FeeAssessment memory fees = _assessFees(strategy, gain, loss);\n\n        ShareManagement memory shares = ISharesManager(sharesManager).calculateShareManagement(loss, fees.totalFees, fees.protocolFees);\n\n        (uint256 previouslyLockedShares, uint256 newlyLockedShares) = ISharesManager(sharesManager).handleShareBurnsAndIssues(shares, fees, gain, loss, strategy);\n\n        ISharesManager(sharesManager).manageUnlockingOfShares(previouslyLockedShares, newlyLockedShares);\n\n        // Record the report of profit timestamp.\n        strategies[strategy].lastReport = block.timestamp;\n\n        // We have to recalculate the fees paid for cases with an overall loss.\n        emit StrategyReported(\n            strategy,\n            gain,\n            loss,\n            strategies[strategy].currentDebt,\n            ISharesManager(sharesManager).convertToAssets(shares.protocolFeesShares, Rounding.ROUND_DOWN),\n            ISharesManager(sharesManager).convertToAssets(shares.protocolFeesShares + shares.accountantFeesShares, Rounding.ROUND_DOWN),\n            fees.totalRefunds\n        );\n\n        return (gain, loss);\n    }\n\n    // Assess the profit and loss of a strategy.\n    function _assessProfitAndLoss(address strategy) internal view returns (uint256 gain, uint256 loss) {\n        // Vault assesses profits using 4626 compliant interface.\n        // NOTE: It is important that a strategies `convertToAssets` implementation\n        // cannot be manipulated or else the vault could report incorrect gains/losses.\n        uint256 strategyShares = IStrategy(strategy).balanceOf(address(this));\n        // How much the vaults position is worth.\n        uint256 currentTotalAssets = IStrategy(strategy).convertToAssets(strategyShares);\n        // How much the vault had deposited to the strategy.\n        uint256 currentDebt = strategies[strategy].currentDebt;\n\n        uint256 _gain = 0;\n        uint256 _loss = 0;\n\n        // Compare reported assets vs. the current debt.\n        if (currentTotalAssets > currentDebt) {\n            // We have a gain.\n            _gain = currentTotalAssets - currentDebt;\n        } else {\n            // We have a loss.\n            _loss = currentDebt - currentTotalAssets;\n        }\n\n        return (_gain, _loss);\n    }\n\n    // Calculate and distribute any fees and refunds from the strategy's performance.\n    function _assessFees(address strategy, uint256 gain, uint256 loss) internal returns (FeeAssessment memory) {\n        FeeAssessment memory fees;\n\n        // If accountant is not set, fees and refunds remain unchanged.\n        if (accountant != address(0)) {\n            (fees.totalFees, fees.totalRefunds) = IAccountant(accountant).report(strategy, gain, loss);\n\n            // Protocol fees will be 0 if accountant fees are 0.\n            if (fees.totalFees > 0) {\n                uint16 protocolFeeBps;\n                // Get the config for this vault.\n                (protocolFeeBps, fees.protocolFeeRecipient) = IFactory(FACTORY).protocolFeeConfig();\n                \n                if (protocolFeeBps > 0) {\n                    // Protocol fees are a percent of the fees the accountant is charging.\n                    fees.protocolFees = fees.totalFees * uint256(protocolFeeBps) / MAX_BPS;\n                }\n            }\n        }\n\n        return fees;\n    }\n}\n    "
    },
    "contracts/test/mocks/MockTokenizedStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport {TokenizedStrategy, ERC20} from \"./TokenizedStrategy.sol\";\n\ncontract MockTokenizedStrategy is TokenizedStrategy {\n    // solhint-disable ordering\n    // solhint-disable var-name-mixedcase\n    // solhint-disable not-rely-on-time\n    // solhint-disable custom-errors\n    // solhint-disable comprehensive-interface\n\n    uint256 public minDebt;\n    uint256 public maxDebt = type(uint256).max;\n\n    // Private variables and functions used in this mock.\n    bytes32 public constant BASE_STRATEGY_STORAGE =\n        bytes32(uint256(keccak256(\"yearn.base.strategy.storage\")) - 1);\n\n    function strategyStorage() internal pure returns (StrategyData storage S) {\n        // Since STORAGE_SLOT is a constant, we have to put a variable\n        // on the stack to access it from an inline assembly block.\n        bytes32 slot = BASE_STRATEGY_STORAGE;\n        assembly {\n            S.slot := slot\n        }\n    }\n\n    constructor(\n        address _asset,\n        string memory _name,\n        address _management,\n        address _keeper\n    ) {\n        // Cache storage pointer\n        StrategyData storage S = strategyStorage();\n\n        // Set the strategy's underlying asset\n        S.asset = ERC20(_asset);\n        // Set the Strategy Tokens name.\n        S.name = _name;\n        // Set decimals based off the `asset`.\n        S.decimals = ERC20(_asset).decimals();\n\n        // Set last report to this block.\n        S.lastReport = uint128(block.timestamp);\n\n        // Set the default management address. Can't be 0.\n        require(_management != address(0), \"ZERO ADDRESS\");\n        S.management = _management;\n        S.performanceFeeRecipient = _management;\n        // Set the keeper address\n        S.keeper = _keeper;\n    }\n\n    function setMinDebt(uint256 _minDebt) external {\n        minDebt = _minDebt;\n    }\n\n    function setMaxDebt(uint256 _maxDebt) external {\n        maxDebt = _maxDebt;\n    }\n\n    function availableDepositLimit(\n        address\n    ) public view virtual returns (uint256) {\n        uint256 _totalAssets = strategyStorage().totalIdle;\n        uint256 _maxDebt = maxDebt;\n        return _maxDebt > _totalAssets ? _maxDebt - _totalAssets : 0;\n    }\n\n    function availableWithdrawLimit(\n        address /*_owner*/\n    ) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function deployFunds(uint256 _amount) external virtual {}\n\n    function freeFunds(uint256 _amount) external virtual {}\n\n    function harvestAndReport() external virtual returns (uint256) {\n        return strategyStorage().asset.balanceOf(address(this));\n    }\n}"
    },
    "contracts/test/mocks/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Token is ERC20 {\n    // solhint-disable ordering\n    // solhint-disable comprehensive-interface\n\n    uint8 public decimals_;\n\n    constructor(string memory _name, uint8 _decimals) ERC20(_name, _name) {\n        decimals_ = _decimals;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return decimals_;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n}"
    },
    "contracts/test/mocks/TokenizedStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.16;\n\n/**$$$$$$$$$$$$$$$$$$$$$$$$$$$&Mr/|1+~>>iiiiiiiiiii>~+{|tuMW$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$B#j]->iiiiiiiiiiiiiiiiiiiiiiiiiiii>-?f*B$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$@zj}~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~}fv@$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$@z(+iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii+)zB$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$Mf~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~t#@$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$@u[iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii?n@$$$$$$$$$$$$$\n$$$$$$$$$$$@z]iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii?u@$$$$$$$$$$$\n$$$$$$$$$$v]iiiiiiiiiiiiiiii,.';iiiiiiiiiiiiiiiiiiiiiiiiii;'.\"iiiiiiiiiiiiiiii?u$$$$$$$$$$\n$$$$$$$$%)>iiiiiiiiiiiiiii,.    ';iiiiiiiiiiiiiiiiiiiiii;'    .\"iiiiiiiiiiiiiiii1%$$$$$$$$\n$$$$$$$c~iiiiiiiiiiiiiii,.        ';iiiiiiiiiiiiiiiiii;'        .\"iiiiiiiiiiiiiii~u$$$$$$$\n$$$$$B/>iiiiiiiiiiiiii!'            `IiiiiiiiiiiiiiiI`            .Iiiiiiiiiiiiiii>|%$$$$$\n$$$$@)iiiiiiiiiiiiiiiii;'             `Iiiiiiiiiiil`             ';iiiiiiiiiiiiiiiii}@$$$$\n$$$B|iiiiiiiiiiiiiiiiiiii;'             `Iiiiiiil`             ';iiiiiiiiiiiiiiiiiiii1B$$$\n$$@)iiiiiiiiiiiiiiiiiiiiiii:'             `;iiI`             ':iiiiiiiiiiiiiiiiiiiiiii{B$$\n$$|iiiiiiiiiiiiiiiiiiiiiiiiii;'             ``             ':iiiiiiiiiiiiiiiiiiiiiiiiii1$$\n$v>iiiiiiiiiiiiiiiiiiiiiiiiiiii:'                        ':iiiiiiiiiiiiiiiiiiiiiiiiiiii>x$\n&?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'                    .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-W\nziiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'                .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv\n-iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'            .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-\n<iiiiiiiiiiiiiiiiiiii!.':iiiiiiiiiiiiii,          \"iiiiiiiiiiiiii;'.Iiiiiiiiiiiiiiiiiiiii<\niiiiiiiiiiiiiiiiiiiii'   ';iiiiiiiiiiiii          Iiiiiiiiiiiii;'   .iiiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii,      ';iiiiiiiiiii          IiiiiiiiiiiI`      `iiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii.        `Iiiiiiiiii          Iiiiiiiii!`         !iiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiii;          :iiiiiiiii          Iiiiiiiii!          ,iiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiii,          iiiiiiiiii          Iiiiiiiiii.         ^iiiiiiiiiiiiiiiiiii\n<iiiiiiiiiiiiiiiiii,          iiiiiiiiii          Iiiiiiiiii'         ^iiiiiiiiiiiiiiiiii<\n-iiiiiiiiiiiiiiiiii;          Iiiiiiiiii          Iiiiiiiiii.         \"iiiiiiiiiiiiiiiiii-\nziiiiiiiiiiiiiiiiiii.         'iiiiiiiii''''''''''liiiiiiii^          liiiiiiiiiiiiiiiiiiv\n&?iiiiiiiiiiiiiiiiii^          ^iiiiiiiiiiiiiiiiiiiiiiiiii,          `iiiiiiiiiiiiiiiiii_W\n$u>iiiiiiiiiiiiiiiiii.          `!iiiiiiiiiiiiiiiiiiiiiii^          .liiiiiiiiiiiiiiiiiir$\n$$(iiiiiiiiiiiiiiiiii;.          .\"iiiiiiiiiiiiiiiiiiii,.           :iiiiiiiiiiiiiiiiii}$$\n$$@{iiiiiiiiiiiiiiiiii;.           .`:iiiiiiiiiiiiii;^.            :iiiiiiiiiiiiiiiiii}B$$\n$$$B)iiiiiiiiiiiiiiiiii!'              '`\",::::,\"`'.             .Iiiiiiiiiiiiiiiiiii{%$$$\n$$$$@1iiiiiiiiiiiiiiiiiii,.                                     ^iiiiiiiiiiiiiiiiiii[@$$$$\n$$$$$B|>iiiiiiiiiiiiiiiiii!^.                                 `liiiiiiiiiiiiiiiiii>)%$$$$$\n$$$$$$$c~iiiiiiiiiiiiiiiiiiii\"'                            .\"!iiiiiiiiiiiiiiiiiii~n$$$$$$$\n$$$$$$$$B)iiiiiiiiiiiiiiiiiiiii!,`.                    .'\"liiiiiiiiiiiiiiiiiiiii1%$$$$$$$$\n$$$$$$$$$@u]iiiiiiiiiiiiiiiiiiiiiiil,^`'..      ..''^,liiiiiiiiiiiiiiiiiiiiiii-x@$$$$$$$$$\n$$$$$$$$$$$@v?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-x$$$$$$$$$$$$\n$$$$$$$$$$$$$@n?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-rB$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$/~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<\\*@$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$Bc1~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~{v%$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$Bvf]<iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<]tuB$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$%zt-+>iiiiiiiiiiiiiiiiiiiiiiiiiiiii+_tc%$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$W#u/|{+~>iiiiiiiiiiii><+{|/n#W$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IFactory} from \"../../Interfaces/IFactory.sol\";\nimport {IBaseStrategy} from \"../../Interfaces/IBaseStrategy.sol\";\n\n/**\n * @title Yearn Tokenized Strategy\n * @author yearn.finance\n * @notice\n *  This TokenizedStrategy can be used by anyone wishing to easily build\n *  and deploy their own custom ERC4626 compliant single strategy Vault.\n *\n *  The TokenizedStrategy contract is meant to be used as a proxy style\n *  implementation contract that will handle all logic, storage and\n *  management for a custom strategy that inherits the `BaseStrategy`.\n *  Any function calls to the strategy that are not defined within that\n *  strategy will be forwarded through a delegateCall to this contract.\n\n *  A strategist only needs to override a few simple functions that are\n *  focused entirely on the strategy specific needs to easily and cheaply\n *  deploy their own permissionless 4626 compliant vault.\n */\ncontract TokenizedStrategy {\n    // solhint-disable ordering\n    // solhint-disable var-name-mixedcase\n    // solhint-disable not-rely-on-time\n    // solhint-disable custom-errors\n    // solhint-disable comprehensive-interface\n    // solhint-disable code-complexity\n    // solhint-disable func-name-mixedcase\n    // solhint-disable function-max-lines\n\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Emitted when the 'pendingManagement' address is updated to 'newPendingManagement'.\n     */\n    event UpdatePendingManagement(address indexed newPendingManagement);\n\n    /**\n     * @notice Emitted when the 'management' address is updated to 'newManagement'.\n     */\n    event UpdateManagement(address indexed newManagement);\n\n    /**\n     * @notice Emitted when the 'keeper' address is updated to 'newKeeper'.\n     */\n    event UpdateKeeper(address indexed newKeeper);\n\n    /**\n     * @notice Emitted when the 'emergencyAdmin' address is updated to 'newEmergencyAdmin'.\n     */\n    event UpdateEmergencyAdmin(address indexed newEmergencyAdmin);\n\n    /**\n     * @notice Emitted when the 'performanceFee' is updated to 'newPerformanceFee'.\n     */\n    event UpdatePerformanceFee(uint16 newPerformanceFee);\n\n    /**\n     * @notice Emitted when the 'performanceFeeRecipient' address is\n     * updated to 'newPerformanceFeeRecipient'.\n     */\n    event UpdatePerformanceFeeRecipient(\n        address indexed newPerformanceFeeRecipient\n    );\n\n    /**\n     * @notice Emitted when the 'profitMaxUnlockTime' is updated to 'newProfitMaxUnlockTime'.\n     */\n    event UpdateProfitMaxUnlockTime(uint256 newProfitMaxUnlockTime);\n\n    /**\n     * @notice Emitted when a strategy is shutdown.\n     */\n    event StrategyShutdown();\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the `caller` has exchanged `assets` for `shares`,\n     * and transferred those `shares` to `owner`.\n     */\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Emitted when the `caller` has exchanged `owner`s `shares` for `assets`,\n     * and transferred those `assets` to `receiver`.\n     */\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Emitted when the strategy reports `profit` or `loss` and\n     * `performanceFees` and `protocolFees` are paid out.\n     */\n    event Reported(\n        uint256 profit,\n        uint256 loss,\n        uint256 protocolFees,\n        uint256 performanceFees\n    );\n\n    /**\n     * @dev Emitted on the initialization of any new `strategy` that uses `asset`\n     * with this specific `apiVersion`.\n     */\n    event NewTokenizedStrategy(\n        address indexed strategy,\n        address indexed asset,\n        string apiVersion\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                        STORAGE STRUCT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev The struct that will hold all the data for each strategy that\n     * uses this implementation.\n     *\n     * This replaces all state variables for a traditional contract. This\n     * full struct will be initialized on the creation of the strategy\n     * and continually updated and read from for the life of the contract.\n     *\n     * We combine all the variables into one struct to limit the amount of\n     * times the custom storage slots need to be loaded during complex functions.\n     *\n     * Loading the corresponding storage slot for the struct does not\n     * load any of the contents of the struct into memory. So the size\n     * has no effect on gas usage.\n     */\n    // prettier-ignore\n    struct StrategyData {\n        // The ERC20 compliant underlying asset that will be\n        // used by the Strategy\n        ERC20 asset;\n\n\n        // These are the corresponding ERC20 variables needed for the\n        // strategies token that is issued and burned on each deposit or withdraw.\n        uint8 decimals; // The amount of decimals that `asset` and strategy use.\n        string name; // The name of the token for the strategy.\n        uint256 totalSupply; // The total amount of shares currently issued.\n        uint256 INITIAL_CHAIN_ID; // The initial chain id when the strategy was created.\n        bytes32 INITIAL_DOMAIN_SEPARATOR; // The domain separator used for permits on the initial chain.\n        mapping(address => uint256) nonces; // Mapping of nonces used for permit functions.\n        mapping(address => uint256) balances; // Mapping to track current balances for each account that holds shares.\n        mapping(address => mapping(address => uint256)) allowances; // Mapping to track the allowances for the strategies shares.\n\n\n        // Assets data to track totals the strategy holds.\n        // We manually track idle instead of relying on asset.balanceOf(address(this))\n        // to prevent PPS manipulation through airdrops.\n        uint256 totalIdle; // The total amount of loose `asset` the strategy holds.\n        uint256 totalDebt; // The total amount `asset` that is currently deployed by the strategy.\n\n\n        // Variables for profit reporting and locking.\n        // We use uint128 for time stamps which is 1,025 years in the future.\n        uint256 profitUnlockingRate; // The rate at which locked profit is unlocking.\n        uint128 fullProfitUnlockDate; // The timestamp at which all locked shares will unlock.\n        uint128 lastReport; // The last time a {report} was called.\n        uint32 profitMaxUnlockTime; // The amount of seconds that the reported profit unlocks over.\n        uint16 performanceFee; // The percent in basis points of profit that is charged as a fee.\n        address performanceFeeRecipient; // The address to pay the `performanceFee` to.\n\n\n        // Access management variables.\n        address management; // Main address that can set all configurable variables.\n        address keeper; // Address given permission to call {report} and {tend}.\n        address pendingManagement; // Address that is pending to take over `management`.\n        address emergencyAdmin; // Address to act in emergencies as well as `management`.\n        bool entered; // Bool to prevent reentrancy.\n        bool shutdown; // Bool that can be used to stop deposits into the strategy.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Require that the call is coming from the strategies management.\n     */\n    modifier onlyManagement() {\n        isManagement(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Require that the call is coming from either the strategies\n     * management or the keeper.\n     */\n    modifier onlyKeepers() {\n        isKeeperOrManagement(msg.sender);\n        _;\n    }\n\n    modifier onlyEmergencyAuthorized() {\n        isEmergencyAuthorized(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Placed over all state changing functions for increased safety.\n     */\n    modifier nonReentrant() {\n        StrategyData storage S = _strategyStorage();\n        // On the first call to nonReentrant, `entered` will be false\n        require(!S.entered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        S.entered = true;\n\n        _;\n\n        // Reset to false once call has finished\n        S.entered = false;\n    }\n\n    /**\n     * @notice To check if a sender is the management for a specific strategy.\n     * @dev Is left public so that it can be used by the Strategy.\n     *\n     * When the Strategy calls this the msg.sender would be the\n     * address of the strategy so we need to specify the sender.\n     *\n     * Will return `true` if the check passed.\n     *\n     * @param _sender The original msg.sender.\n     */\n    function isManagement(address _sender) public view returns (bool) {\n        require(_sender == _strategyStorage().management, \"!management\");\n        return true;\n    }\n\n    /**\n     * @notice To check if a sender is the keeper or management\n     * for a specific strategy.\n     * @dev Is left public so that it can be used by the Strategy.\n     *\n     * When the Strategy calls this the msg.sender would be the\n     * address of the strategy so we need to specify the sender.\n     *\n     * Will return `true` if the check passed.\n     *\n     * @param _sender The original msg.sender.\n     */\n    function isKeeperOrManagement(address _sender) public view returns (bool) {\n        StrategyData storage S = _strategyStorage();\n        require(_sender == S.keeper || _sender == S.management, \"!keeper\");\n        return true;\n    }\n\n    /**\n     * @notice To check if a sender is the keeper or emergency admin\n     * for a specific strategy.\n     * @dev Is left public so that it can be used by the Strategy.\n     *\n     * When the Strategy calls this the msg.sender would be the\n     * address of the strategy so we need to specify the sender.\n     *\n     * Will return `true` if the check passed.\n     *\n     * @param _sender The original msg.sender.\n     */\n    function isEmergencyAuthorized(address _sender) public view returns (bool) {\n        StrategyData storage S = _strategyStorage();\n        require(\n            _sender == S.emergencyAdmin || _sender == S.management,\n            \"!emergency authorized\"\n        );\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    // API version this TokenizedStrategy implements.\n    string private constant API_VERSION = \"3.0.1\";\n\n    // Used for fee calculations.\n    uint256 private constant MAX_BPS = 10_000;\n    // Used for profit unlocking rate calculations.\n    uint256 private constant MAX_BPS_EXTENDED = 1_000_000_000_000;\n\n    // Minimum in Basis points the Performance fee can be set to.\n    // Used to disincentive forking strategies just to lower fees.\n    uint16 public constant MIN_FEE = 500; // 5%\n    // Maximum in Basis Points the Performance Fee can be set to.\n    uint16 public constant MAX_FEE = 5_000; // 50%\n\n    // Seconds per year for max profit unlocking time.\n    uint256 private constant SECONDS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    // Address of the previously deployed Vault factory that the\n    // protocol fee config is retrieved from.\n    // NOTE: This will be set to deployed factory. deterministic address for testing is used now\n    address public constant FACTORY =\n        0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n\n    /**\n     * @dev Custom storage slot that will be used to store the\n     * `StrategyData` struct that holds each strategies\n     * specific storage variables.\n     *\n     * Any storage updates done by the TokenizedStrategy actually update\n     * the storage of the calling contract. This variable points\n     * to the specific location that will be used to store the\n     * struct that holds all that data.\n     *\n     * We use a custom string in order to get a random\n     * storage slot that will allow for strategists to use any\n     * amount of storage in their strategy without worrying\n     * about collisions.\n     */\n    bytes32 private constant BASE_STRATEGY_STORAGE =\n        bytes32(uint256(keccak256(\"yearn.base.strategy.storage\")) - 1);\n\n    /*//////////////////////////////////////////////////////////////\n                    STORAGE GETTER FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev will return the actual storage slot where the strategy\n     * specific `StrategyData` struct is stored for both read\n     * and write operations.\n     *\n     * This loads just the slot location, not the full struct\n     * so it can be used in a gas efficient manner.\n     */\n    function _strategyStorage() private pure returns (StrategyData storage S) {\n        // Since STORAGE_SLOT is a constant, we have to put a variable\n        // on the stack to access it from an inline assembly block.\n        bytes32 slot = BASE_STRATEGY_STORAGE;\n        assembly {\n            S.slot := slot\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                INITIALIZATION OF DEFAULT STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Used to initialize storage for a newly deployed strategy.\n     * @dev This should be called atomically whenever a new strategy is\n     * deployed and can only be called once for each strategy.\n     *\n     * This will set all the default storage that must be set for a\n     * strategy to function. Any changes can be made post deployment\n     * through external calls from `management`.\n     *\n     * The function will also emit an event that off chain indexers can\n     * look for to track any new deployments using this TokenizedStrategy.\n     *\n     * This is called through a low level call in the BaseStrategy\n     * so any reverts will return the \"init failed\" string.\n     *\n     * @param _asset Address of the underlying asset.\n     * @param _name Name the strategy will use.\n     * @param _management Address to set as the strategies `management`.\n     * @param _performanceFeeRecipient Address to receive performance fees.\n     * @param _keeper Address to set as strategies `keeper`.\n     */\n    function init(\n        address _asset,\n        string memory _name,\n        address _management,\n        address _performanceFeeRecipient,\n        address _keeper\n    ) external {\n        // Cache storage pointer\n        StrategyData storage S = _strategyStorage();\n\n        // Make sure we aren't initialized.\n        require(address(S.asset) == address(0), \"initialized\");\n\n        // Set the strategy's underlying asset\n        S.asset = ERC20(_asset);\n        // Set the Strategy Tokens name.\n        S.name = _name;\n        // Set decimals based off the `asset`.\n        S.decimals = ERC20(_asset).decimals();\n        // Set initial chain id for permit replay protection\n        S.INITIAL_CHAIN_ID = block.chainid;\n        // Set the initial domain separator for permit functions\n        S.INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\n\n        // Default to a 10 day profit unlock period\n        S.profitMaxUnlockTime = 10 days;\n        // Set address to receive performance fees.\n        // Can't be address(0) or we will be burning fees.\n        require(_performanceFeeRecipient != address(0), \"ZERO ADDRESS\");\n        // Can't mint shares to its self because of profit locking.\n        require(_performanceFeeRecipient != address(this), \"self\");\n        S.performanceFeeRecipient = _performanceFeeRecipient;\n        // Default to a 10% performance fee.\n        S.performanceFee = 1_000;\n        // Set last report to this block.\n        S.lastReport = uint128(block.timestamp);\n\n        // Set the default management address. Can't be 0.\n        require(_management != address(0), \"ZERO ADDRESS\");\n        S.management = _management;\n        // Set the keeper address\n        S.keeper = _keeper;\n\n        // Emit event to signal a new strategy has been initialized.\n        emit NewTokenizedStrategy(address(this), _asset, API_VERSION);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints `shares` of strategy shares to `receiver` by\n     * depositing exactly `assets` of underlying tokens.\n     * @param assets The amount of underlying to deposit in.\n     * @param receiver The address to receive the `shares`.\n     * @return shares The actual amount of shares issued.\n     */\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) external nonReentrant returns (uint256 shares) {\n        // Checking max deposit will also check if shutdown.\n        require(\n            assets <= maxDeposit(receiver),\n            \"ERC4626: deposit more than max\"\n        );\n        // Check for rounding error.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        _deposit(receiver, assets, shares);\n    }\n\n    /**\n     * @notice Mints exactly `shares` of strategy shares to\n     * `receiver` by depositing `assets` of underlying tokens.\n     * @param shares The amount of strategy shares mint.\n     * @param receiver The address to receive the `shares`.\n     * @return assets The actual amount of asset deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) external nonReentrant returns (uint256 assets) {\n        // Checking max mint will also check if shutdown.\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n        // Check for rounding error.\n        require((assets = previewMint(shares)) != 0, \"ZERO_ASSETS\");\n\n        _deposit(receiver, assets, shares);\n    }\n\n    /**\n     * @notice Withdraws exactly `assets` from `owners` shares and sends\n     * the underlying tokens to `receiver`.\n     * @dev This will default to not allowing any loss to be taken.\n     * @param assets The amount of underlying to withdraw.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @return shares The actual amount of shares burnt.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares) {\n        return withdraw(assets, receiver, owner, 0);\n    }\n\n    /**\n     * @notice Withdraws `assets` from `owners` shares and sends\n     * the underlying tokens to `receiver`.\n     * @dev This includes an added parameter to allow for losses.\n     * @param assets The amount of underlying to withdraw.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @param maxLoss The amount of acceptable loss in Basis points.\n     * @return shares The actual amount of shares burnt.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxLoss\n    ) public nonReentrant returns (uint256 shares) {\n        require(\n            assets <= maxWithdraw(owner),\n            \"ERC4626: withdraw more than max\"\n        );\n        // Check for rounding error or 0 value.\n        require((shares = previewWithdraw(assets)) != 0, \"ZERO_SHARES\");\n\n        // Withdraw and track the actual amount withdrawn for loss check.\n        _withdraw(receiver, owner, assets, shares, maxLoss);\n    }\n\n    /**\n     * @notice Redeems exactly `shares` from `owner` and\n     * sends `assets` of underlying tokens to `receiver`.\n     * @dev This will default to allowing any loss passed to be realized.\n     * @param shares The amount of shares burnt.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @return assets The actual amount of underlying withdrawn.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256) {\n        // We default to not limiting a potential loss.\n        return redeem(shares, receiver, owner, MAX_BPS);\n    }\n\n    /**\n     * @notice Redeems exactly `shares` from `owner` and\n     * sends `assets` of underlying tokens to `receiver`.\n     * @dev This includes an added parameter to allow for losses.\n     * @param shares The amount of shares burnt.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @param maxLoss The amount of acceptable loss in Basis points.\n     * @return . The actual amount of underlying withdrawn.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 maxLoss\n    ) public nonReentrant returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n        uint256 assets;\n        // Check for rounding error or 0 value.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        // We need to return the actual amount withdrawn in case of a loss.\n        return _withdraw(receiver, owner, assets, shares, maxLoss);\n    }\n\n    /**\n     * @notice The amount of shares that the strategy would\n     *  exchange for the amount of assets provided, in an\n     * ideal scenario where all the conditions are met.\n     *\n     * @param assets The amount of underlying.\n     * @return . Expected shares that `assets` represents.\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        // Saves an extra SLOAD if totalAssets() is non-zero.\n        uint256 _totalAssets = totalAssets();\n        uint256 _totalSupply = totalSupply();\n\n        // If assets are 0 but supply is not PPS = 0.\n        if (_totalAssets == 0) return _totalSupply == 0 ? assets : 0;\n\n        return assets.mulDiv(_totalSupply, _totalAssets, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice The amount of assets that the strategy would\n     * exchange for the amount of shares provided, in an\n     * ideal scenario where all the conditions are met.\n     *\n     * @param shares The amount of the strategies shares.\n     * @return . Expected amount of `asset` the shares represents.\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        // Saves an extra SLOAD if totalSupply() is non-zero.\n        uint256 supply = totalSupply();\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     * @dev This will round down.\n     *\n     * @param assets The amount of `asset` to deposits.\n     * @return . Expected shares that would be issued.\n     */\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their mint at the current block, given\n     * current on-chain conditions.\n     * @dev This is used instead of convertToAssets so that it can\n     * round up for safer mints.\n     *\n     * @param shares The amount of shares to mint.\n     * @return . The needed amount of `asset` for the mint.\n     */\n    function previewMint(uint256 shares) public view returns (uint256) {\n        // Saves an extra SLOAD if totalSupply() is non-zero.\n        uint256 supply = totalSupply();\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Up);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     * @dev This is used instead of convertToShares so that it can\n     * round up for safer withdraws.\n     *\n     * @param assets The amount of `asset` that would be withdrawn.\n     * @return . The amount of shares that would be burnt.\n     */\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        // Saves an extra SLOAD if totalAssets() is non-zero.\n        uint256 _totalAssets = totalAssets();\n        uint256 _totalSupply = totalSupply();\n\n        // If assets are 0 but supply is not, then PPS = 0.\n        if (_totalAssets == 0) return _totalSupply == 0 ? assets : 0;\n\n        return assets.mulDiv(_totalSupply, _totalAssets, Math.Rounding.Up);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     * @dev This will round down.\n     *\n     * @param shares The amount of shares that would be redeemed.\n     * @return . The amount of `asset` that would be returned.\n     */\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /**\n     * @notice Total number of underlying assets that can\n     * be deposited by `_owner` into the strategy, where `owner`\n     * corresponds to the receiver of a {deposit} call.\n     *\n     * @param owner The address depositing.\n     * @return . The max that `owner` can deposit in `asset`.\n     */\n    function maxDeposit(address owner) public view returns (uint256) {\n        if (_strategyStorage().shutdown) return 0;\n\n        return IBaseStrategy(address(this)).availableDepositLimit(owner);\n    }\n\n    /**\n     * @notice Total number of shares that can be minted by `owner`\n     * into the strategy, where `_owner` corresponds to the receiver\n     * of a {mint} call.\n     *\n     * @param owner The address minting.\n     * @return _maxMint The max that `owner` can mint in shares.\n     */\n    function maxMint(address owner) public view returns (uint256 _maxMint) {\n        if (_strategyStorage().shutdown) return 0;\n\n        _maxMint = IBaseStrategy(address(this)).availableDepositLimit(owner);\n        if (_maxMint != type(uint256).max) {\n            _maxMint = convertToShares(_maxMint);\n        }\n    }\n\n    /**\n     * @notice Total number of underlying assets that can be\n     * withdrawn from the strategy by `owner`, where `owner`\n     * corresponds to the msg.sender of a {redeem} call.\n     *\n     * @param owner The owner of the shares.\n     * @return _maxWithdraw Max amount of `asset` that can be withdrawn.\n     */\n    function maxWithdraw(\n        address owner\n    ) public view returns (uint256 _maxWithdraw) {\n        _maxWithdraw = IBaseStrategy(address(this)).availableWithdrawLimit(\n            owner\n        );\n        if (_maxWithdraw == type(uint256).max) {\n            // Saves a min check if there is no withdrawal limit.\n            _maxWithdraw = convertToAssets(balanceOf(owner));\n        } else {\n            _maxWithdraw = Math.min(\n                convertToAssets(balanceOf(owner)),\n                _maxWithdraw\n            );\n        }\n    }\n\n    /**\n     * @notice Total number of strategy shares that can be\n     * redeemed from the strategy by `owner`, where `owner`\n     * corresponds to the msg.sender of a {redeem} call.\n     *\n     * @param owner The owner of the shares.\n     * @return _maxRedeem Max amount of shares that can be redeemed.\n     */\n    function maxRedeem(address owner) public view returns (uint256 _maxRedeem) {\n        _maxRedeem = IBaseStrategy(address(this)).availableWithdrawLimit(owner);\n        // Conversion would overflow and saves a min check if there is no withdrawal limit.\n        if (_maxRedeem == type(uint256).max) {\n            _maxRedeem = balanceOf(owner);\n        } else {\n            _maxRedeem = Math.min(\n                // Use preview withdraw to round up\n                previewWithdraw(_maxRedeem),\n                balanceOf(owner)\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the total amount of assets this strategy holds\n     * as of the last report.\n     *\n     * We manually track debt and idle to avoid any PPS manipulation\n     * from donations, touch values of debt etc.\n     *\n     * @return . Total assets the strategy holds.\n     */\n    function totalAssets() public view returns (uint256) {\n        StrategyData storage S = _strategyStorage();\n        unchecked {\n            return S.totalIdle + S.totalDebt;\n        }\n    }\n\n    /**\n     * @notice Get the current supply of the strategies shares.\n     *\n     * Locked shares issued to the strategy from profits are not\n     * counted towards the full supply until they are unlocked.\n     *\n     * As more shares slowly unlock the totalSupply will decrease\n     * causing the PPS of the strategy to increase.\n     *\n     * @return . Total amount of shares issued.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _strategyStorage().totalSupply - _unlockedShares();\n    }\n\n    /**\n     * @dev Function to be called during {deposit} and {mint}.\n     *\n     * This function handles all logic including transfers,\n     * minting and accounting.\n     *\n     * We do all external calls before updating any internal\n     * values to prevent view reentrancy issues from the token\n     * transfers or the _deployFunds() calls.\n     */\n    function _deposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) private {\n        require(receiver != address(this), \"ERC4626: mint to self\");\n\n        // Cache storage variables used more than once.\n        StrategyData storage S = _strategyStorage();\n        ERC20 _asset = S.asset;\n\n        // Need to transfer before minting or ERC777s could reenter.\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        // We will deposit up to current idle plus the new amount added\n        uint256 toDeploy = S.totalIdle + assets;\n\n        // Cache for post {deployFunds} checks.\n        uint256 beforeBalance = _asset.balanceOf(address(this));\n\n        // Deploy up to all loose funds.\n        IBaseStrategy(address(this)).deployFunds(toDeploy);\n\n        // Always get the actual amount deployed. We double check the\n        // diff against toDeploy for complete accuracy.\n        uint256 deployed = Math.min(\n            beforeBalance - _asset.balanceOf(address(this)),\n            toDeploy\n        );\n\n        // Adjust total Assets.\n        S.totalDebt += deployed;\n        unchecked {\n            // Cant't underflow due to previous min check.\n            S.totalIdle = toDeploy - deployed;\n        }\n\n        // mint shares\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /**\n     * @dev To be called during {redeem} and {withdraw}.\n     *\n     * This will handle all logic, transfers and accounting\n     * in order to service the withdraw request.\n     *\n     * If we are not able to withdraw the full amount needed, it will\n     * be counted as a loss and passed on to the user.\n     */\n    function _withdraw(\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares,\n        uint256 maxLoss\n    ) private returns (uint256) {\n        require(receiver != address(0), \"ZERO ADDRESS\");\n        require(maxLoss <= MAX_BPS, \"exceeds MAX_BPS\");\n\n        // Spend allowance if applicable.\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        StrategyData storage S = _strategyStorage();\n        // Expected behavior is to need to free funds so we cache `_asset`.\n        ERC20 _asset = S.asset;\n\n        uint256 idle = S.totalIdle;\n\n        // Check if we need to withdraw funds.\n        if (idle < assets) {\n            // Cache before balance for diff checks.\n            uint256 before = _asset.balanceOf(address(this));\n\n            // Tell Strategy to free what we need.\n            unchecked {\n                IBaseStrategy(address(this)).freeFunds(assets - idle);\n            }\n\n            // Return the actual amount withdrawn. Adjust for potential over withdraws.\n            uint256 withdrawn = Math.min(\n                _asset.balanceOf(address(this)) - before,\n                S.totalDebt\n            );\n\n            unchecked {\n                idle += withdrawn;\n            }\n\n            uint256 loss;\n            // If we didn't get enough out then we have a loss.\n            if (idle < assets) {\n                unchecked {\n                    loss = assets - idle;\n                }\n                // If a non-default max loss parameter was set.\n                if (maxLoss < MAX_BPS) {\n                    // Make sure we are within the acceptable range.\n                    require(\n                        loss <= (assets * maxLoss) / MAX_BPS,\n                        \"too much loss\"\n                    );\n                }\n                // Lower the amount to be withdrawn.\n                assets = idle;\n            }\n\n            // Update debt storage.\n            S.totalDebt -= (withdrawn + loss);\n        }\n\n        // Update idle based on how much we took.\n        S.totalIdle = idle - assets;\n\n        _burn(owner, shares);\n\n        _asset.safeTransfer(receiver, assets);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // Return the actual amount of assets withdrawn.\n        return assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        PROFIT LOCKING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function for keepers to call to harvest and record all\n     * profits accrued.\n     *\n     * @dev This should be called through protected relays if swaps\n     * are likely occur.\n     *\n     * This will account for any gains/losses since the last report\n     * and charge fees accordingly.\n     *\n     * Any profit over the fees charged will be immediately locked\n     * so there is no change in PricePerShare. Then slowly unlocked\n     * over the `maxProfitUnlockTime` each second based on the\n     * calculated `profitUnlockingRate`.\n     *\n     * In case of a loss it will first attempt to offset the loss\n     * with any remaining locked shares from the last report in\n     * order to reduce any negative impact to PPS.\n     *\n     * Will then recalculate the new time to unlock profits over and the\n     * rate based on a weighted average of any remaining time from the\n     * last report and the new amount of shares to be locked.\n     *\n     * @return profit The notional amount of gain if any since the last\n     * report in terms of `asset`.\n     * @return loss The notional amount of loss if any since the last\n     * report in terms of `asset`.\n     */\n    function report()\n        external\n        nonReentrant\n        onlyKeepers\n        returns (uint256 profit, uint256 loss)\n    {\n        // Cache storage pointer since its used repeatedly.\n        StrategyData storage S = _strategyStorage();\n\n        uint256 oldTotalAssets;\n        unchecked {\n            // Manually calculate totalAssets to save a SLOAD.\n            oldTotalAssets = S.totalIdle + S.totalDebt;\n        }\n\n        // Tell the strategy to report the real total assets it has.\n        // It should do all reward selling and redepositing now and\n        // account for deployed and loose `asset` so we can accurately\n        // account for all funds including those potentially airdropped\n        // by a trade factory. It is safe here to use asset.balanceOf()\n        // instead of totalIdle because any profits are immediately locked.\n        uint256 newTotalAssets = IBaseStrategy(address(this))\n            .harvestAndReport();\n\n        // Burn unlocked shares.\n        _burnUnlockedShares();\n\n        // Initialize variables needed throughout.\n        uint256 totalFees;\n        uint256 protocolFees;\n        uint256 sharesToLock;\n        uint256 _profitMaxUnlockTime = S.profitMaxUnlockTime;\n        // Calculate profit/loss.\n        if (newTotalAssets > oldTotalAssets) {\n            // We have a profit.\n            unchecked {\n                profit = newTotalAssets - oldTotalAssets;\n                // Asses performance fees.\n                totalFees = (profit * S.performanceFee) / MAX_BPS;\n            }\n\n            address protocolFeesRecipient;\n            uint256 performanceFeeShares;\n            uint256 protocolFeeShares;\n            // If performance fees are 0 so will protocol fees.\n            if (totalFees != 0) {\n                // Get the config from the factory.\n                uint16 protocolFeeBps;\n                (protocolFeeBps, protocolFeesRecipient) = IFactory(FACTORY)\n                    .protocolFeeConfig();\n\n                // Check if there is a protocol fee to charge.\n                if (protocolFeeBps != 0) {\n                    // Calculate protocol fees based on the performance Fees.\n                    protocolFees = (totalFees * protocolFeeBps) / MAX_BPS;\n                }\n\n                // We need to get the shares to issue for the fees at\n                // current PPS before any minting or burning.\n                unchecked {\n                    performanceFeeShares = convertToShares(\n                        totalFees - protocolFees\n                    );\n                }\n                if (protocolFees != 0) {\n                    protocolFeeShares = convertToShares(protocolFees);\n                }\n            }\n\n            // we have a net profit. Check if we are locking profit.\n            if (_profitMaxUnlockTime != 0) {\n                // lock (profit - fees)\n                unchecked {\n                    sharesToLock = convertToShares(profit - totalFees);\n                }\n                // Mint the shares to lock the strategy.\n                _mint(address(this), sharesToLock);\n            }\n\n            // Mint fees shares to recipients.\n            if (performanceFeeShares != 0) {\n                _mint(S.performanceFeeRecipient, performanceFeeShares);\n            }\n\n            if (protocolFeeShares != 0) {\n                _mint(protocolFeesRecipient, protocolFeeShares);\n            }\n        } else {\n            // We have a loss.\n            unchecked {\n                loss = oldTotalAssets - newTotalAssets;\n            }\n\n            // Check in case else was due to being equal.\n            if (loss != 0) {\n                // We will try and burn shares from any pending profit still unlocking\n                // to offset the loss to prevent any PPS decline post report.\n                uint256 sharesToBurn = Math.min(\n                    S.balances[address(this)],\n                    convertToShares(loss)\n                );\n\n                // Check if there is anything to burn.\n                if (sharesToBurn != 0) {\n                    _burn(address(this), sharesToBurn);\n                }\n            }\n        }\n\n        // Update unlocking rate and time to fully unlocked.\n        uint256 totalLockedShares = S.balances[address(this)];\n        if (totalLockedShares != 0) {\n            uint256 previouslyLockedTime;\n            uint128 _fullProfitUnlockDate = S.fullProfitUnlockDate;\n            // Check if we need to account for shares still unlocking.\n            if (_fullProfitUnlockDate > block.timestamp) {\n                unchecked {\n                    // There will only be previously locked shares if time remains.\n                    // We calculate this here since it should be rare.\n                    previouslyLockedTime =\n                        (_fullProfitUnlockDate - block.timestamp) *\n                        (totalLockedShares - sharesToLock);\n                }\n            }\n\n            // newProfitLockingPeriod is a weighted average between the remaining\n            // time of the previously locked shares and the profitMaxUnlockTime.\n            uint256 newProfitLockingPeriod = (previouslyLockedTime +\n                sharesToLock *\n                _profitMaxUnlockTime) / totalLockedShares;\n\n            // Calculate how many shares unlock per second.\n            S.profitUnlockingRate =\n                (totalLockedShares * MAX_BPS_EXTENDED) /\n                newProfitLockingPeriod;\n\n            // Calculate how long until the full amount of shares is unlocked.\n            S.fullProfitUnlockDate = uint128(\n                block.timestamp + newProfitLockingPeriod\n            );\n        } else {\n            // Only setting this to 0 will turn in the desired effect,\n            // no need to update fullProfitUnlockDate.\n            S.profitUnlockingRate = 0;\n        }\n\n        // Update storage we use the actual loose here since it should have\n        // been accounted for in `harvestAndReport` and any airdropped amounts\n        // would have been locked to prevent PPS manipulation.\n        uint256 newIdle = S.asset.balanceOf(address(this));\n        S.totalIdle = newIdle;\n        S.totalDebt = newTotalAssets - newIdle;\n\n        S.lastReport = uint128(block.timestamp);\n\n        // Emit event with info\n        emit Reported(\n            profit,\n            loss,\n            protocolFees, // Protocol fees\n            totalFees - protocolFees // Performance Fees\n        );\n    }\n\n    /**\n     * @dev Called during reports to burn shares that have been unlocked\n     * since the last report.\n     *\n     * Will reset the `lastReport` if haven't unlocked the full amount yet\n     * so future calculations remain correct.\n     */\n    function _burnUnlockedShares() private {\n        uint256 unlocked = _unlockedShares();\n        if (unlocked == 0) {\n            return;\n        }\n\n        // update variables (done here to keep _unlockedShares() as a view function)\n        if (_strategyStorage().fullProfitUnlockDate > block.timestamp) {\n            _strategyStorage().lastReport = uint128(block.timestamp);\n        }\n\n        _burn(address(this), unlocked);\n    }\n\n    /**\n     * @notice Get how many shares have been unlocked since last report.\n     * @return . The amount of shares that have unlocked.\n     */\n    function unlockedShares() external view returns (uint256) {\n        return _unlockedShares();\n    }\n\n    /**\n     * @dev To determine how many of the shares that were locked during the last\n     * report have since unlocked.\n     *\n     * If the `fullProfitUnlockDate` has passed the full strategy's balance will\n     * count as unlocked.\n     *\n     * @return unlocked The amount of shares that have unlocked.\n     */\n    function _unlockedShares() private view returns (uint256 unlocked) {\n        // should save 2 extra calls for most scenarios.\n        StrategyData storage S = _strategyStorage();\n        uint128 _fullProfitUnlockDate = S.fullProfitUnlockDate;\n        if (_fullProfitUnlockDate > block.timestamp) {\n            unchecked {\n                unlocked =\n                    (S.profitUnlockingRate * (block.timestamp - S.lastReport)) /\n                    MAX_BPS_EXTENDED;\n            }\n        } else if (_fullProfitUnlockDate != 0) {\n            // All shares have been unlocked.\n            unlocked = S.balances[address(this)];\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        TENDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice For a 'keeper' to 'tend' the strategy if a custom\n     * tendTrigger() is implemented.\n     *\n     * @dev Both 'tendTrigger' and '_tend' will need to be overridden\n     * for this to be used.\n     *\n     * This will callback the internal '_tend' call in the BaseStrategy\n     * with the total current amount available to the strategy to deploy.\n     *\n     * Keepers are expected to use protected relays in tend calls so this\n     * can be used for illiquid or manipulatable strategies to compound\n     * rewards, perform maintenance or deposit/withdraw funds.\n     *\n     * All accounting for totalDebt and totalIdle updates will be done\n     * here post '_tend'.\n     *\n     * This should never cause an increase in PPS. Total assets should\n     * be the same before and after\n     *\n     * A report() call will be needed to record the profit.\n     */\n    function tend() external nonReentrant onlyKeepers {\n        // Tend the strategy with the current totalIdle.\n        IBaseStrategy(address(this)).tendThis(_strategyStorage().totalIdle);\n\n        // Update balances based on ending state.\n        _updateBalances();\n    }\n\n    /**\n     * @notice Update the internal balances that make up `totalAssets`.\n     * @dev This will update the ratio of debt and idle that make up\n     * totalAssets based on the actual current loose amount of `asset`\n     * in a safe way. But will keep `totalAssets` the same, thus having\n     * no effect on Price Per Share.\n     */\n    function _updateBalances() internal {\n        StrategyData storage S = _strategyStorage();\n\n        // Get the current loose balance.\n        uint256 assetBalance = S.asset.balanceOf(address(this));\n\n        // If its already accurate do nothing.\n        if (S.totalIdle == assetBalance) return;\n\n        // Get the total assets the strategy should have.\n        uint256 _totalAssets = totalAssets();\n\n        // If we have enough loose to cover all assets.\n        if (assetBalance >= _totalAssets) {\n            // Set idle to totalAssets.\n            S.totalIdle = _totalAssets;\n            // Set debt to 0.\n            S.totalDebt = 0;\n        } else {\n            // Otherwise idle is the actual loose balance.\n            S.totalIdle = assetBalance;\n            unchecked {\n                // And debt is the difference.\n                S.totalDebt = _totalAssets - assetBalance;\n            }\n        }\n\n        // Enforce the invariant.\n        require(_totalAssets == totalAssets(), \"!totalAssets\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        STRATEGY SHUTDOWN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Used to shutdown the strategy preventing any further deposits.\n     * @dev Can only be called by the current `management` or `emergencyAdmin`.\n     *\n     * This will stop any new {deposit} or {mint} calls but will\n     * not prevent {withdraw} or {redeem}. It will also still allow for\n     * {tend} and {report} so that management can report any last losses\n     * in an emergency as well as provide any maintenance to allow for full\n     * withdraw.\n     *\n     * This is a one way switch and can never be set back once shutdown.\n     */\n    function shutdownStrategy() external onlyEmergencyAuthorized {\n        _strategyStorage().shutdown = true;\n\n        emit StrategyShutdown();\n    }\n\n    /**\n     * @notice To manually withdraw funds from the yield source after a\n     * strategy has been shutdown.\n     * @dev This can only be called post {shutdownStrategy}.\n     *\n     * This will update totalDebt and totalIdle based on the amount of\n     * loose `asset` after the withdraw leaving `totalAssets` unchanged.\n     *\n     * A strategist will need to override the {_emergencyWithdraw} function\n     * in their strategy for this to work.\n     *\n     * @param amount The amount of asset to attempt to free.\n     */\n    function emergencyWithdraw(\n        uint256 amount\n    ) external nonReentrant onlyEmergencyAuthorized {\n        // Make sure the strategy has been shutdown.\n        require(_strategyStorage().shutdown, \"not shutdown\");\n\n        // Withdraw from the yield source.\n        IBaseStrategy(address(this)).shutdownWithdraw(amount);\n\n        // Record the updated balances based on the new amounts.\n        _updateBalances();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GETTER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the underlying asset for the strategy.\n     * @return . The underlying asset.\n     */\n    function asset() external view returns (address) {\n        return address(_strategyStorage().asset);\n    }\n\n    /**\n     * @notice Get the API version for this TokenizedStrategy.\n     * @return . The API version for this TokenizedStrategy\n     */\n    function apiVersion() external pure returns (string memory) {\n        return API_VERSION;\n    }\n\n    /**\n     * @notice Get the current total idle for a strategy.\n     * @return . The current amount of idle funds.\n     */\n    function totalIdle() external view returns (uint256) {\n        return _strategyStorage().totalIdle;\n    }\n\n    /**\n     * @notice Get the current total debt for a strategy.\n     * @return . The current amount of debt.\n     */\n    function totalDebt() external view returns (uint256) {\n        return _strategyStorage().totalDebt;\n    }\n\n    /**\n     * @notice Get the current address that controls the strategy.\n     * @return . Address of management\n     */\n    function management() external view returns (address) {\n        return _strategyStorage().management;\n    }\n\n    /**\n     * @notice Get the current pending management address if any.\n     * @return . Address of pendingManagement\n     */\n    function pendingManagement() external view returns (address) {\n        return _strategyStorage().pendingManagement;\n    }\n\n    /**\n     * @notice Get the current address that can call tend and report.\n     * @return . Address of the keeper\n     */\n    function keeper() external view returns (address) {\n        return _strategyStorage().keeper;\n    }\n\n    /**\n     * @notice Get the current address that can shutdown and emergency withdraw.\n     * @return . Address of the emergencyAdmin\n     */\n    function emergencyAdmin() external view returns (address) {\n        return _strategyStorage().emergencyAdmin;\n    }\n\n    /**\n     * @notice Get the current performance fee charged on profits.\n     * denominated in Basis Points where 10_000 == 100%\n     * @return . Current performance fee.\n     */\n    function performanceFee() external view returns (uint16) {\n        return _strategyStorage().performanceFee;\n    }\n\n    /**\n     * @notice Get the current address that receives the performance fees.\n     * @return . Address of performanceFeeRecipient\n     */\n    function performanceFeeRecipient() external view returns (address) {\n        return _strategyStorage().performanceFeeRecipient;\n    }\n\n    /**\n     * @notice Gets the timestamp at which all profits will be unlocked.\n     * @return . The full profit unlocking timestamp\n     */\n    function fullProfitUnlockDate() external view returns (uint256) {\n        return uint256(_strategyStorage().fullProfitUnlockDate);\n    }\n\n    /**\n     * @notice The per second rate at which profits are unlocking.\n     * @dev This is denominated in EXTENDED_BPS decimals.\n     * @return . The current profit unlocking rate.\n     */\n    function profitUnlockingRate() external view returns (uint256) {\n        return _strategyStorage().profitUnlockingRate;\n    }\n\n    /**\n     * @notice Gets the current time profits are set to unlock over.\n     * @return . The current profit max unlock time.\n     */\n    function profitMaxUnlockTime() external view returns (uint256) {\n        return _strategyStorage().profitMaxUnlockTime;\n    }\n\n    /**\n     * @notice The timestamp of the last time protocol fees were charged.\n     * @return . The last report.\n     */\n    function lastReport() external view returns (uint256) {\n        return uint256(_strategyStorage().lastReport);\n    }\n\n    /**\n     * @notice Get the price per share.\n     * @dev This value offers limited precision. Integrations that require\n     * exact precision should use convertToAssets or convertToShares instead.\n     *\n     * @return . The price per share.\n     */\n    function pricePerShare() external view returns (uint256) {\n        return convertToAssets(10 ** _strategyStorage().decimals);\n    }\n\n    /**\n     * @notice To check if the strategy has been shutdown.\n     * @return . Whether or not the strategy is shutdown.\n     */\n    function isShutdown() public view returns (bool) {\n        return _strategyStorage().shutdown;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        SETTER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Step one of two to set a new address to be in charge of the strategy.\n     * @dev Can only be called by the current `management`. The address is\n     * set to pending management and will then have to call {acceptManagement}\n     * in order for the 'management' to officially change.\n     *\n     * Cannot set `management` to address(0).\n     *\n     * @param _management New address to set `pendingManagement` to.\n     */\n    function setPendingManagement(address _management) external onlyManagement {\n        require(_management != address(0), \"ZERO ADDRESS\");\n        _strategyStorage().pendingManagement = _management;\n\n        emit UpdatePendingManagement(_management);\n    }\n\n    /**\n     * @notice Step two of two to set a new 'management' of the strategy.\n     * @dev Can only be called by the current `pendingManagement`.\n     */\n    function acceptManagement() external {\n        require(msg.sender == _strategyStorage().pendingManagement, \"!pending\");\n        _strategyStorage().management = msg.sender;\n        _strategyStorage().pendingManagement = address(0);\n\n        emit UpdateManagement(msg.sender);\n    }\n\n    /**\n     * @notice Sets a new address to be in charge of tend and reports.\n     * @dev Can only be called by the current `management`.\n     *\n     * @param _keeper New address to set `keeper` to.\n     */\n    function setKeeper(address _keeper) external onlyManagement {\n        _strategyStorage().keeper = _keeper;\n\n        emit UpdateKeeper(_keeper);\n    }\n\n    /**\n     * @notice Sets a new address to be able to shutdown the strategy.\n     * @dev Can only be called by the current `management`.\n     *\n     * @param _emergencyAdmin New address to set `emergencyAdmin` to.\n     */\n    function setEmergencyAdmin(\n        address _emergencyAdmin\n    ) external onlyManagement {\n        _strategyStorage().emergencyAdmin = _emergencyAdmin;\n\n        emit UpdateEmergencyAdmin(_emergencyAdmin);\n    }\n\n    /**\n     * @notice Sets the performance fee to be charged on reported gains.\n     * @dev Can only be called by the current `management`.\n     *\n     * Denominated in Basis Points. So 100% == 10_000.\n     * Cannot be set less than the MIN_FEE.\n     * Cannot set greater than to MAX_FEE.\n     *\n     * @param _performanceFee New performance fee.\n     */\n    function setPerformanceFee(uint16 _performanceFee) external onlyManagement {\n        require(_performanceFee >= MIN_FEE, \"MIN FEE\");\n        require(_performanceFee <= MAX_FEE, \"MAX FEE\");\n        _strategyStorage().performanceFee = _performanceFee;\n\n        emit UpdatePerformanceFee(_performanceFee);\n    }\n\n    /**\n     * @notice Sets a new address to receive performance fees.\n     * @dev Can only be called by the current `management`.\n     *\n     * Cannot set to address(0).\n     *\n     * @param _performanceFeeRecipient New address to set `management` to.\n     */\n    function setPerformanceFeeRecipient(\n        address _performanceFeeRecipient\n    ) external onlyManagement {\n        require(_performanceFeeRecipient != address(0), \"ZERO ADDRESS\");\n        require(_performanceFeeRecipient != address(this), \"Cannot be self\");\n        _strategyStorage().performanceFeeRecipient = _performanceFeeRecipient;\n\n        emit UpdatePerformanceFeeRecipient(_performanceFeeRecipient);\n    }\n\n    /**\n     * @notice Sets the time for profits to be unlocked over.\n     * @dev Can only be called by the current `management`.\n     *\n     * Denominated in seconds and cannot be greater than 1 year.\n     *\n     * NOTE: Setting to 0 will cause all currently locked profit\n     * to be unlocked instantly and should be done with care.\n     *\n     * `profitMaxUnlockTime` is stored as a uint32 for packing but can\n     * be passed in as uint256 for simplicity.\n     *\n     * @param _profitMaxUnlockTime New `profitMaxUnlockTime`.\n     */\n    function setProfitMaxUnlockTime(\n        uint256 _profitMaxUnlockTime\n    ) external onlyManagement {\n        // Must be less than a year.\n        require(_profitMaxUnlockTime <= SECONDS_PER_YEAR, \"too long\");\n        StrategyData storage S = _strategyStorage();\n\n        // If we are setting to 0 we need to adjust amounts.\n        if (_profitMaxUnlockTime == 0) {\n            // Burn all shares if applicable.\n            _burn(address(this), S.balances[address(this)]);\n            // Reset unlocking variables\n            S.profitUnlockingRate = 0;\n            S.fullProfitUnlockDate = 0;\n        }\n\n        S.profitMaxUnlockTime = uint32(_profitMaxUnlockTime);\n\n        emit UpdateProfitMaxUnlockTime(_profitMaxUnlockTime);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC20 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token.\n     * @return . The name the strategy is using for its token.\n     */\n    function name() external view returns (string memory) {\n        return _strategyStorage().name;\n    }\n\n    /**\n     * @notice Returns the symbol of the strategies token.\n     * @dev Will be 'ys + asset symbol'.\n     * @return . The symbol the strategy is using for its tokens.\n     */\n    function symbol() public view returns (string memory) {\n        return\n            string(abi.encodePacked(\"ys\", _strategyStorage().asset.symbol()));\n    }\n\n    /**\n     * @notice Returns the number of decimals used to get its user representation.\n     * @return . The decimals used for the strategy and `asset`.\n     */\n    function decimals() public view returns (uint8) {\n        return _strategyStorage().decimals;\n    }\n\n    /**\n     * @notice Returns the current balance for a given '_account'.\n     * @dev If the '_account` is the strategy then this will subtract\n     * the amount of shares that have been unlocked since the last profit first.\n     * @param account the address to return the balance for.\n     * @return . The current balance in y shares of the '_account'.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        if (account == address(this)) {\n            return _strategyStorage().balances[account] - _unlockedShares();\n        }\n        return _strategyStorage().balances[account];\n    }\n\n    /**\n     * @notice Transfer '_amount` of shares from `msg.sender` to `to`.\n     * @dev\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `to` cannot be the address of the strategy.\n     * - the caller must have a balance of at least `_amount`.\n     *\n     * @param to The address shares will be transferred to.\n     * @param amount The amount of shares to be transferred from sender.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     * @param owner The address who owns the shares.\n     * @param spender The address who would be moving the owners shares.\n     * @return . The remaining amount of shares of `owner` that could be moved by `spender`.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) public view returns (uint256) {\n        return _strategyStorage().allowances[owner][spender];\n    }\n\n    /**\n     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n     * @dev\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\n     * @param spender the address to allow the shares to be moved by.\n     * @param amount the amount of shares to allow `spender` to move.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * @dev\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `to` cannot be the address of the strategy.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     *\n     * Emits a {Transfer} event.\n     *\n     * @param from the address to be moving shares from.\n     * @param to the address to be moving shares to.\n     * @param amount the quantity of shares to move.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - cannot give spender over uint256.max allowance\n     *\n     * @param spender the account that will be able to move the senders shares.\n     * @param addedValue the extra amount to add to the current allowance.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\n     * @param spender the account that will be able to move less of the senders shares.\n     * @param subtractedValue the amount to decrease the current allowance by.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, allowance(owner, spender) - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `to` cannot be the strategies address\n     * - `from` must have a balance of at least `amount`.\n     *\n     */\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(to != address(this), \"ERC20 transfer to strategy\");\n        StrategyData storage S = _strategyStorage();\n\n        S.balances[from] -= amount;\n        unchecked {\n            S.balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\n     */\n    function _mint(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        StrategyData storage S = _strategyStorage();\n\n        S.totalSupply += amount;\n        unchecked {\n            S.balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        StrategyData storage S = _strategyStorage();\n\n        S.balances[account] -= amount;\n        unchecked {\n            S.totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _strategyStorage().allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * @dev Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * @param _owner the address of the account to return the nonce for.\n     * @return . the current nonce for the account.\n     */\n    function nonces(address _owner) external view returns (uint256) {\n        return _strategyStorage().nonces[_owner];\n    }\n\n    /**\n     * @notice Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * @dev IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"ERC20: PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                _strategyStorage().nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"ERC20: INVALID_SIGNER\"\n            );\n\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    /**\n     * @notice Returns the domain separator used in the encoding of the signature\n     * for {permit}, as defined by {EIP712}.\n     *\n     * @dev This checks that the current chain id is the same as when the contract\n     * was deployed to prevent replay attacks. If false it will calculate a new\n     * domain separator based on the new chain id.\n     *\n     * @return . The domain separator that will be used for any {permit} calls.\n     */\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        StrategyData storage S = _strategyStorage();\n        return\n            block.chainid == S.INITIAL_CHAIN_ID\n                ? S.INITIAL_DOMAIN_SEPARATOR\n                : _computeDomainSeparator();\n    }\n\n    /**\n     * @dev Calculates and returns the domain separator to be used in any\n     * permit functions for the strategies {permit} calls.\n     *\n     * This will be used at the initialization of each new strategies storage.\n     * It would then be used in the future in the case of any forks in which\n     * the current chain id is not the same as the original.\n     *\n     */\n    function _computeDomainSeparator() private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(_strategyStorage().name)),\n                    keccak256(bytes(API_VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DEPLOYMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev On contract creation we set `asset` for this contract to address(1).\n     * This prevents it from ever being initialized in the future.\n     */\n    constructor() {\n        _strategyStorage().asset = ERC20(address(1));\n    }\n}"
    },
    "contracts/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL 3.0\n// Copyright Fathom 2023\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./VaultStructs.sol\";\n\ncontract VaultStorage {\n    // CONSTANTS\n    // The max length the withdrawal queue can be.\n    uint256 public constant MAX_QUEUE = 10;\n    // 100% in Basis Points.\n    uint256 public constant MAX_BPS = 10000;\n    // Extended for profit locking calculations.\n    uint256 public constant MAX_BPS_EXTENDED = 1000000000000;\n    // The version of this vault.\n    string public constant API_VERSION = \"1.0.0\";\n    uint256 public immutable ONE_YEAR = 31556952;\n\n    address public strategyManager;\n    address public sharesManager;\n    address public setters;\n    address public governance;\n\n    // STORAGE\n    // HashMap that records all the strategies that are allowed to receive assets from the vault.\n    mapping(address => StrategyParams) public strategies;\n\n    // The current default withdrawal queue.\n    address[] public defaultQueue;\n\n    // Should the vault use the default_queue regardless whats passed in.\n    bool public useDefaultQueue;\n\n    // ERC20 - amount of shares per account\n    mapping(address => uint256) internal _balanceOf;\n    // ERC20 - owner -> (spender -> amount)\n    mapping(address => mapping(address => uint256)) internal _allowance;\n\n    // Total amount of shares that are currently minted including those locked.\n    // NOTE: To get the ERC20 compliant version use totalSupply().\n    uint256 public totalSupplyAmount;\n\n    // Total amount of assets that has been deposited in strategies.\n    uint256 public totalDebtAmount;\n    // Current assets held in the vault contract. Replacing balanceOf(this) to avoid price_per_share manipulation.\n    uint256 public totalIdleAmount;\n    // Minimum amount of assets that should be kept in the vault contract to allow for fast, cheap redeems.\n    uint256 public minimumTotalIdle;\n    // Maximum amount of tokens that the vault can accept. If totalAssets > deposit_limit, deposits will revert.\n    uint256 public depositLimit;\n    // Contract that charges fees and can give refunds.\n    address public accountant;\n    // Contract to control the deposit limit.\n    address public depositLimitModule;\n    // Contract to control the withdraw limit.\n    address public withdrawLimitModule;\n\n    // HashMap mapping addresses to their roles\n    mapping(address => bytes32) public roles;\n    // HashMap mapping roles to their permissioned state. If false, the role is not open to the public.\n    mapping(bytes32 => bool) public openRoles;\n\n    // Address that can add and remove roles to addresses.\n    address public roleManager;\n    // Temporary variable to store the address of the next role_manager until the role is accepted.\n    address public futureRoleManager;\n\n    // State of the vault - if set to true, only withdrawals will be available. It can't be reverted.\n    bool public shutdown;\n    // The amount of time profits will unlock over.\n    uint256 public profitMaxUnlockTime;\n    // The timestamp of when the current unlocking period ends.\n    uint256 public fullProfitUnlockDate;\n    // The per second rate at which profit will unlock.\n    uint256 public profitUnlockingRate;\n    // Last timestamp of the most recent profitable report.\n    uint256 public lastProfitUpdate;\n\n    // EIP-2612 permit() nonces and typehashes\n    mapping(address => uint256) public nonces;\n    bytes32 public constant DOMAIN_TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPE_HASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // Roles\n    bytes32 public constant ACCOUNTANT_MANAGER = keccak256(\"ACCOUNTANT_MANAGER\");\n    bytes32 public constant QUEUE_MANAGER = keccak256(\"QUEUE_MANAGER\");\n    bytes32 public constant DEPOSIT_LIMIT_MANAGER = keccak256(\"DEPOSIT_LIMIT_MANAGER\");\n    bytes32 public constant WITHDRAW_LIMIT_MANAGER = keccak256(\"WITHDRAW_LIMIT_MANAGER\");\n    bytes32 public constant MINIMUM_IDLE_MANAGER = keccak256(\"MINIMUM_IDLE_MANAGER\");\n    bytes32 public constant PROFIT_UNLOCK_MANAGER = keccak256(\"PROFIT_UNLOCK_MANAGER\");\n    bytes32 public constant ROLE_MANAGER = keccak256(\"ROLE_MANAGER\");\n    bytes32 public constant REPORTING_MANAGER = keccak256(\"REPORTING_MANAGER\");\n    bytes32 public constant DEBT_PURCHASER = keccak256(\"DEBT_PURCHASER\");\n    bytes32 public constant ADD_STRATEGY_MANAGER = keccak256(\"ADD_STRATEGY_MANAGER\");\n    bytes32 public constant REVOKE_STRATEGY_MANAGER = keccak256(\"REVOKE_STRATEGY_MANAGER\");\n    bytes32 public constant FORCE_REVOKE_MANAGER = keccak256(\"FORCE_REVOKE_MANAGER\");\n    bytes32 public constant MAX_DEBT_MANAGER = keccak256(\"MAX_DEBT_MANAGER\");\n    bytes32 public constant DEBT_MANAGER = keccak256(\"DEBT_MANAGER\");\n    bytes32 public constant EMERGENCY_MANAGER = keccak256(\"EMERGENCY_MANAGER\");         \n}"
    },
    "contracts/VaultStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL 3.0\n// Copyright Fathom 2023\n\npragma solidity ^0.8.16;\n\nstruct StrategyParams {\n    uint256 activation;\n    uint256 lastReport;\n    uint256 currentDebt;\n    uint256 maxDebt;\n}\n\nstruct FeeAssessment {\n    uint256 totalFees;\n    uint256 totalRefunds;\n    uint256 protocolFees;\n    address protocolFeeRecipient;\n}\n\nstruct ShareManagement {\n    uint256 sharesToBurn;\n    uint256 accountantFeesShares;\n    uint256 protocolFeesShares;\n}\n\nstruct WithdrawalState {\n    uint256 requestedAssets;\n    uint256 currTotalIdle;\n    uint256 currTotalDebt;\n    uint256 assetsNeeded;\n    uint256 previousBalance;\n    uint256 unrealisedLossesShare;\n}\n\n// ENUMS\nenum StrategyChangeType {\n    ADDED, // Corresponds to the strategy being added.\n    REVOKED // Corresponds to the strategy being revoked.\n}\n\nenum RoleStatusChange {\n    OPENED, // Corresponds to a role being opened.\n    CLOSED // Corresponds to a role being closed.\n}\n\nenum Rounding {\n    ROUND_DOWN, // Corresponds to rounding down to the nearest whole number.\n    ROUND_UP // Corresponds to rounding up to the nearest whole number.\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}