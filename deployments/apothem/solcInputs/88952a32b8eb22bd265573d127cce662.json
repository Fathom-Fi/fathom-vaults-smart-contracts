{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/Interfaces/IBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.16;\n\ninterface IBaseStrategy {\n    // solhint-disable ordering\n\n    function tokenizedStrategyAddress() external view returns (address);\n\n    /*//////////////////////////////////////////////////////////////\n                            IMMUTABLE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function availableDepositLimit(\n        address _owner\n    ) external view returns (uint256);\n\n    function availableWithdrawLimit(\n        address _owner\n    ) external view returns (uint256);\n\n    function deployFunds(uint256 _assets) external;\n\n    function freeFunds(uint256 _amount) external;\n\n    function harvestAndReport() external returns (uint256);\n\n    function tendThis(uint256 _totalIdle) external;\n\n    function shutdownWithdraw(uint256 _amount) external;\n\n    function tendTrigger() external view returns (bool, bytes memory);\n}"
    },
    "contracts/Interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\ninterface IFactory {\n    function protocolFeeConfig() external view returns (uint16, address);\n}"
    },
    "contracts/test/mocks/MockTokenizedStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport {TokenizedStrategy, ERC20} from \"./TokenizedStrategy.sol\";\n\ncontract MockTokenizedStrategy is TokenizedStrategy {\n    // solhint-disable ordering\n    // solhint-disable var-name-mixedcase\n    // solhint-disable not-rely-on-time\n    // solhint-disable custom-errors\n    // solhint-disable comprehensive-interface\n\n    uint256 public minDebt;\n    uint256 public maxDebt = type(uint256).max;\n\n    // Private variables and functions used in this mock.\n    bytes32 public constant BASE_STRATEGY_STORAGE =\n        bytes32(uint256(keccak256(\"yearn.base.strategy.storage\")) - 1);\n\n    function strategyStorage() internal pure returns (StrategyData storage S) {\n        // Since STORAGE_SLOT is a constant, we have to put a variable\n        // on the stack to access it from an inline assembly block.\n        bytes32 slot = BASE_STRATEGY_STORAGE;\n        assembly {\n            S.slot := slot\n        }\n    }\n\n    constructor(\n        address _asset,\n        string memory _name,\n        address _management,\n        address _keeper,\n        uint32 _profitMaxUnlockTime\n    ) {\n        // Cache storage pointer\n        StrategyData storage S = strategyStorage();\n\n        // Set the strategy's underlying asset\n        S.asset = ERC20(_asset);\n        // Set the Strategy Tokens name.\n        S.name = _name;\n        // Set decimals based off the `asset`.\n        S.decimals = ERC20(_asset).decimals();\n\n        // Set last report to this block.\n        S.lastReport = uint128(block.timestamp);\n\n        // Set the default management address. Can't be 0.\n        require(_management != address(0), \"ZERO ADDRESS\");\n        S.management = _management;\n        S.performanceFeeRecipient = _management;\n        // Set the keeper address\n        S.keeper = _keeper;\n        S.profitMaxUnlockTime = _profitMaxUnlockTime;\n    }\n\n    function setMinDebt(uint256 _minDebt) external {\n        minDebt = _minDebt;\n    }\n\n    function setMaxDebt(uint256 _maxDebt) external {\n        maxDebt = _maxDebt;\n    }\n\n    function availableDepositLimit(\n        address\n    ) public view virtual returns (uint256) {\n        uint256 _totalAssets = strategyStorage().totalIdle;\n        uint256 _maxDebt = maxDebt;\n        return _maxDebt > _totalAssets ? _maxDebt - _totalAssets : 0;\n    }\n\n    function availableWithdrawLimit(\n        address /*_owner*/\n    ) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function deployFunds(uint256 _amount) external virtual {}\n\n    function freeFunds(uint256 _amount) external virtual {}\n\n    function harvestAndReport() external virtual returns (uint256) {\n        return strategyStorage().asset.balanceOf(address(this));\n    }\n}"
    },
    "contracts/test/mocks/TokenizedStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.16;\n\n/**$$$$$$$$$$$$$$$$$$$$$$$$$$$&Mr/|1+~>>iiiiiiiiiii>~+{|tuMW$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$B#j]->iiiiiiiiiiiiiiiiiiiiiiiiiiii>-?f*B$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$@zj}~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~}fv@$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$@z(+iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii+)zB$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$Mf~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~t#@$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$@u[iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii?n@$$$$$$$$$$$$$\n$$$$$$$$$$$@z]iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii?u@$$$$$$$$$$$\n$$$$$$$$$$v]iiiiiiiiiiiiiiii,.';iiiiiiiiiiiiiiiiiiiiiiiiii;'.\"iiiiiiiiiiiiiiii?u$$$$$$$$$$\n$$$$$$$$%)>iiiiiiiiiiiiiii,.    ';iiiiiiiiiiiiiiiiiiiiii;'    .\"iiiiiiiiiiiiiiii1%$$$$$$$$\n$$$$$$$c~iiiiiiiiiiiiiii,.        ';iiiiiiiiiiiiiiiiii;'        .\"iiiiiiiiiiiiiii~u$$$$$$$\n$$$$$B/>iiiiiiiiiiiiii!'            `IiiiiiiiiiiiiiiI`            .Iiiiiiiiiiiiiii>|%$$$$$\n$$$$@)iiiiiiiiiiiiiiiii;'             `Iiiiiiiiiiil`             ';iiiiiiiiiiiiiiiii}@$$$$\n$$$B|iiiiiiiiiiiiiiiiiiii;'             `Iiiiiiil`             ';iiiiiiiiiiiiiiiiiiii1B$$$\n$$@)iiiiiiiiiiiiiiiiiiiiiii:'             `;iiI`             ':iiiiiiiiiiiiiiiiiiiiiii{B$$\n$$|iiiiiiiiiiiiiiiiiiiiiiiiii;'             ``             ':iiiiiiiiiiiiiiiiiiiiiiiiii1$$\n$v>iiiiiiiiiiiiiiiiiiiiiiiiiiii:'                        ':iiiiiiiiiiiiiiiiiiiiiiiiiiii>x$\n&?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'                    .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-W\nziiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'                .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv\n-iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'            .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-\n<iiiiiiiiiiiiiiiiiiii!.':iiiiiiiiiiiiii,          \"iiiiiiiiiiiiii;'.Iiiiiiiiiiiiiiiiiiiii<\niiiiiiiiiiiiiiiiiiiii'   ';iiiiiiiiiiiii          Iiiiiiiiiiiii;'   .iiiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii,      ';iiiiiiiiiii          IiiiiiiiiiiI`      `iiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii.        `Iiiiiiiiii          Iiiiiiiii!`         !iiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiii;          :iiiiiiiii          Iiiiiiiii!          ,iiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiii,          iiiiiiiiii          Iiiiiiiiii.         ^iiiiiiiiiiiiiiiiiii\n<iiiiiiiiiiiiiiiiii,          iiiiiiiiii          Iiiiiiiiii'         ^iiiiiiiiiiiiiiiiii<\n-iiiiiiiiiiiiiiiiii;          Iiiiiiiiii          Iiiiiiiiii.         \"iiiiiiiiiiiiiiiiii-\nziiiiiiiiiiiiiiiiiii.         'iiiiiiiii''''''''''liiiiiiii^          liiiiiiiiiiiiiiiiiiv\n&?iiiiiiiiiiiiiiiiii^          ^iiiiiiiiiiiiiiiiiiiiiiiiii,          `iiiiiiiiiiiiiiiiii_W\n$u>iiiiiiiiiiiiiiiiii.          `!iiiiiiiiiiiiiiiiiiiiiii^          .liiiiiiiiiiiiiiiiiir$\n$$(iiiiiiiiiiiiiiiiii;.          .\"iiiiiiiiiiiiiiiiiiii,.           :iiiiiiiiiiiiiiiiii}$$\n$$@{iiiiiiiiiiiiiiiiii;.           .`:iiiiiiiiiiiiii;^.            :iiiiiiiiiiiiiiiiii}B$$\n$$$B)iiiiiiiiiiiiiiiiii!'              '`\",::::,\"`'.             .Iiiiiiiiiiiiiiiiiii{%$$$\n$$$$@1iiiiiiiiiiiiiiiiiii,.                                     ^iiiiiiiiiiiiiiiiiii[@$$$$\n$$$$$B|>iiiiiiiiiiiiiiiiii!^.                                 `liiiiiiiiiiiiiiiiii>)%$$$$$\n$$$$$$$c~iiiiiiiiiiiiiiiiiiii\"'                            .\"!iiiiiiiiiiiiiiiiiii~n$$$$$$$\n$$$$$$$$B)iiiiiiiiiiiiiiiiiiiii!,`.                    .'\"liiiiiiiiiiiiiiiiiiiii1%$$$$$$$$\n$$$$$$$$$@u]iiiiiiiiiiiiiiiiiiiiiiil,^`'..      ..''^,liiiiiiiiiiiiiiiiiiiiiii-x@$$$$$$$$$\n$$$$$$$$$$$@v?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-x$$$$$$$$$$$$\n$$$$$$$$$$$$$@n?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-rB$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$/~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<\\*@$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$Bc1~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~{v%$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$Bvf]<iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<]tuB$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$%zt-+>iiiiiiiiiiiiiiiiiiiiiiiiiiiii+_tc%$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$W#u/|{+~>iiiiiiiiiiii><+{|/n#W$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IFactory} from \"../../Interfaces/IFactory.sol\";\nimport {IBaseStrategy} from \"../../Interfaces/IBaseStrategy.sol\";\n\n/**\n * @title Yearn Tokenized Strategy\n * @author yearn.finance\n * @notice\n *  This TokenizedStrategy can be used by anyone wishing to easily build\n *  and deploy their own custom ERC4626 compliant single strategy Vault.\n *\n *  The TokenizedStrategy contract is meant to be used as a proxy style\n *  implementation contract that will handle all logic, storage and\n *  management for a custom strategy that inherits the `BaseStrategy`.\n *  Any function calls to the strategy that are not defined within that\n *  strategy will be forwarded through a delegateCall to this contract.\n\n *  A strategist only needs to override a few simple functions that are\n *  focused entirely on the strategy specific needs to easily and cheaply\n *  deploy their own permissionless 4626 compliant vault.\n */\ncontract TokenizedStrategy {\n    // solhint-disable ordering\n    // solhint-disable var-name-mixedcase\n    // solhint-disable not-rely-on-time\n    // solhint-disable custom-errors\n    // solhint-disable comprehensive-interface\n    // solhint-disable code-complexity\n    // solhint-disable func-name-mixedcase\n    // solhint-disable function-max-lines\n\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Emitted when the 'pendingManagement' address is updated to 'newPendingManagement'.\n     */\n    event UpdatePendingManagement(address indexed newPendingManagement);\n\n    /**\n     * @notice Emitted when the 'management' address is updated to 'newManagement'.\n     */\n    event UpdateManagement(address indexed newManagement);\n\n    /**\n     * @notice Emitted when the 'keeper' address is updated to 'newKeeper'.\n     */\n    event UpdateKeeper(address indexed newKeeper);\n\n    /**\n     * @notice Emitted when the 'emergencyAdmin' address is updated to 'newEmergencyAdmin'.\n     */\n    event UpdateEmergencyAdmin(address indexed newEmergencyAdmin);\n\n    /**\n     * @notice Emitted when the 'performanceFee' is updated to 'newPerformanceFee'.\n     */\n    event UpdatePerformanceFee(uint16 newPerformanceFee);\n\n    /**\n     * @notice Emitted when the 'performanceFeeRecipient' address is\n     * updated to 'newPerformanceFeeRecipient'.\n     */\n    event UpdatePerformanceFeeRecipient(\n        address indexed newPerformanceFeeRecipient\n    );\n\n    /**\n     * @notice Emitted when the 'profitMaxUnlockTime' is updated to 'newProfitMaxUnlockTime'.\n     */\n    event UpdateProfitMaxUnlockTime(uint256 newProfitMaxUnlockTime);\n\n    /**\n     * @notice Emitted when a strategy is shutdown.\n     */\n    event StrategyShutdown();\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the `caller` has exchanged `assets` for `shares`,\n     * and transferred those `shares` to `owner`.\n     */\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Emitted when the `caller` has exchanged `owner`s `shares` for `assets`,\n     * and transferred those `assets` to `receiver`.\n     */\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Emitted when the strategy reports `profit` or `loss` and\n     * `performanceFees` and `protocolFees` are paid out.\n     */\n    event Reported(\n        uint256 profit,\n        uint256 loss,\n        uint256 protocolFees,\n        uint256 performanceFees\n    );\n\n    /**\n     * @dev Emitted on the initialization of any new `strategy` that uses `asset`\n     * with this specific `apiVersion`.\n     */\n    event NewTokenizedStrategy(\n        address indexed strategy,\n        address indexed asset,\n        string apiVersion\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                        STORAGE STRUCT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev The struct that will hold all the data for each strategy that\n     * uses this implementation.\n     *\n     * This replaces all state variables for a traditional contract. This\n     * full struct will be initialized on the creation of the strategy\n     * and continually updated and read from for the life of the contract.\n     *\n     * We combine all the variables into one struct to limit the amount of\n     * times the custom storage slots need to be loaded during complex functions.\n     *\n     * Loading the corresponding storage slot for the struct does not\n     * load any of the contents of the struct into memory. So the size\n     * has no effect on gas usage.\n     */\n    // prettier-ignore\n    struct StrategyData {\n        // The ERC20 compliant underlying asset that will be\n        // used by the Strategy\n        ERC20 asset;\n\n\n        // These are the corresponding ERC20 variables needed for the\n        // strategies token that is issued and burned on each deposit or withdraw.\n        uint8 decimals; // The amount of decimals that `asset` and strategy use.\n        string name; // The name of the token for the strategy.\n        uint256 totalSupply; // The total amount of shares currently issued.\n        uint256 INITIAL_CHAIN_ID; // The initial chain id when the strategy was created.\n        bytes32 INITIAL_DOMAIN_SEPARATOR; // The domain separator used for permits on the initial chain.\n        mapping(address => uint256) nonces; // Mapping of nonces used for permit functions.\n        mapping(address => uint256) balances; // Mapping to track current balances for each account that holds shares.\n        mapping(address => mapping(address => uint256)) allowances; // Mapping to track the allowances for the strategies shares.\n\n\n        // Assets data to track totals the strategy holds.\n        // We manually track idle instead of relying on asset.balanceOf(address(this))\n        // to prevent PPS manipulation through airdrops.\n        uint256 totalIdle; // The total amount of loose `asset` the strategy holds.\n        uint256 totalDebt; // The total amount `asset` that is currently deployed by the strategy.\n\n\n        // Variables for profit reporting and locking.\n        // We use uint128 for time stamps which is 1,025 years in the future.\n        uint256 profitUnlockingRate; // The rate at which locked profit is unlocking.\n        uint128 fullProfitUnlockDate; // The timestamp at which all locked shares will unlock.\n        uint128 lastReport; // The last time a {report} was called.\n        uint32 profitMaxUnlockTime; // The amount of seconds that the reported profit unlocks over.\n        uint16 performanceFee; // The percent in basis points of profit that is charged as a fee.\n        address performanceFeeRecipient; // The address to pay the `performanceFee` to.\n\n\n        // Access management variables.\n        address management; // Main address that can set all configurable variables.\n        address keeper; // Address given permission to call {report} and {tend}.\n        address pendingManagement; // Address that is pending to take over `management`.\n        address emergencyAdmin; // Address to act in emergencies as well as `management`.\n        bool entered; // Bool to prevent reentrancy.\n        bool shutdown; // Bool that can be used to stop deposits into the strategy.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Require that the call is coming from the strategies management.\n     */\n    modifier onlyManagement() {\n        isManagement(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Require that the call is coming from either the strategies\n     * management or the keeper.\n     */\n    modifier onlyKeepers() {\n        isKeeperOrManagement(msg.sender);\n        _;\n    }\n\n    modifier onlyEmergencyAuthorized() {\n        isEmergencyAuthorized(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Placed over all state changing functions for increased safety.\n     */\n    modifier nonReentrant() {\n        StrategyData storage S = _strategyStorage();\n        // On the first call to nonReentrant, `entered` will be false\n        require(!S.entered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        S.entered = true;\n\n        _;\n\n        // Reset to false once call has finished\n        S.entered = false;\n    }\n\n    /**\n     * @notice To check if a sender is the management for a specific strategy.\n     * @dev Is left public so that it can be used by the Strategy.\n     *\n     * When the Strategy calls this the msg.sender would be the\n     * address of the strategy so we need to specify the sender.\n     *\n     * Will return `true` if the check passed.\n     *\n     * @param _sender The original msg.sender.\n     */\n    function isManagement(address _sender) public view returns (bool) {\n        require(_sender == _strategyStorage().management, \"!management\");\n        return true;\n    }\n\n    /**\n     * @notice To check if a sender is the keeper or management\n     * for a specific strategy.\n     * @dev Is left public so that it can be used by the Strategy.\n     *\n     * When the Strategy calls this the msg.sender would be the\n     * address of the strategy so we need to specify the sender.\n     *\n     * Will return `true` if the check passed.\n     *\n     * @param _sender The original msg.sender.\n     */\n    function isKeeperOrManagement(address _sender) public view returns (bool) {\n        StrategyData storage S = _strategyStorage();\n        require(_sender == S.keeper || _sender == S.management, \"!keeper\");\n        return true;\n    }\n\n    /**\n     * @notice To check if a sender is the keeper or emergency admin\n     * for a specific strategy.\n     * @dev Is left public so that it can be used by the Strategy.\n     *\n     * When the Strategy calls this the msg.sender would be the\n     * address of the strategy so we need to specify the sender.\n     *\n     * Will return `true` if the check passed.\n     *\n     * @param _sender The original msg.sender.\n     */\n    function isEmergencyAuthorized(address _sender) public view returns (bool) {\n        StrategyData storage S = _strategyStorage();\n        require(\n            _sender == S.emergencyAdmin || _sender == S.management,\n            \"!emergency authorized\"\n        );\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    // API version this TokenizedStrategy implements.\n    string private constant API_VERSION = \"3.0.1\";\n\n    // Used for fee calculations.\n    uint256 private constant MAX_BPS = 10_000;\n    // Used for profit unlocking rate calculations.\n    uint256 private constant MAX_BPS_EXTENDED = 1_000_000_000_000;\n\n    // Minimum in Basis points the Performance fee can be set to.\n    // Used to disincentive forking strategies just to lower fees.\n    uint16 public constant MIN_FEE = 500; // 5%\n    // Maximum in Basis Points the Performance Fee can be set to.\n    uint16 public constant MAX_FEE = 5_000; // 50%\n\n    // Seconds per year for max profit unlocking time.\n    uint256 private constant SECONDS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    // Address of the previously deployed Vault factory that the\n    // protocol fee config is retrieved from.\n    // NOTE: This will be set to deployed factory. deterministic address for testing is used now\n    address public constant FACTORY =\n        0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n\n    /**\n     * @dev Custom storage slot that will be used to store the\n     * `StrategyData` struct that holds each strategies\n     * specific storage variables.\n     *\n     * Any storage updates done by the TokenizedStrategy actually update\n     * the storage of the calling contract. This variable points\n     * to the specific location that will be used to store the\n     * struct that holds all that data.\n     *\n     * We use a custom string in order to get a random\n     * storage slot that will allow for strategists to use any\n     * amount of storage in their strategy without worrying\n     * about collisions.\n     */\n    bytes32 private constant BASE_STRATEGY_STORAGE =\n        bytes32(uint256(keccak256(\"yearn.base.strategy.storage\")) - 1);\n\n    /*//////////////////////////////////////////////////////////////\n                    STORAGE GETTER FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev will return the actual storage slot where the strategy\n     * specific `StrategyData` struct is stored for both read\n     * and write operations.\n     *\n     * This loads just the slot location, not the full struct\n     * so it can be used in a gas efficient manner.\n     */\n    function _strategyStorage() private pure returns (StrategyData storage S) {\n        // Since STORAGE_SLOT is a constant, we have to put a variable\n        // on the stack to access it from an inline assembly block.\n        bytes32 slot = BASE_STRATEGY_STORAGE;\n        assembly {\n            S.slot := slot\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                INITIALIZATION OF DEFAULT STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Used to initialize storage for a newly deployed strategy.\n     * @dev This should be called atomically whenever a new strategy is\n     * deployed and can only be called once for each strategy.\n     *\n     * This will set all the default storage that must be set for a\n     * strategy to function. Any changes can be made post deployment\n     * through external calls from `management`.\n     *\n     * The function will also emit an event that off chain indexers can\n     * look for to track any new deployments using this TokenizedStrategy.\n     *\n     * This is called through a low level call in the BaseStrategy\n     * so any reverts will return the \"init failed\" string.\n     *\n     * @param _asset Address of the underlying asset.\n     * @param _name Name the strategy will use.\n     * @param _management Address to set as the strategies `management`.\n     * @param _performanceFeeRecipient Address to receive performance fees.\n     * @param _keeper Address to set as strategies `keeper`.\n     */\n    function init(\n        address _asset,\n        string memory _name,\n        address _management,\n        address _performanceFeeRecipient,\n        address _keeper\n    ) external {\n        // Cache storage pointer\n        StrategyData storage S = _strategyStorage();\n\n        // Make sure we aren't initialized.\n        require(address(S.asset) == address(0), \"initialized\");\n\n        // Set the strategy's underlying asset\n        S.asset = ERC20(_asset);\n        // Set the Strategy Tokens name.\n        S.name = _name;\n        // Set decimals based off the `asset`.\n        S.decimals = ERC20(_asset).decimals();\n        // Set initial chain id for permit replay protection\n        S.INITIAL_CHAIN_ID = block.chainid;\n        // Set the initial domain separator for permit functions\n        S.INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\n\n        // Default to a 10 day profit unlock period\n        S.profitMaxUnlockTime = 10 days;\n        // Set address to receive performance fees.\n        // Can't be address(0) or we will be burning fees.\n        require(_performanceFeeRecipient != address(0), \"ZERO ADDRESS\");\n        // Can't mint shares to its self because of profit locking.\n        require(_performanceFeeRecipient != address(this), \"self\");\n        S.performanceFeeRecipient = _performanceFeeRecipient;\n        // Default to a 10% performance fee.\n        S.performanceFee = 1_000;\n        // Set last report to this block.\n        S.lastReport = uint128(block.timestamp);\n\n        // Set the default management address. Can't be 0.\n        require(_management != address(0), \"ZERO ADDRESS\");\n        S.management = _management;\n        // Set the keeper address\n        S.keeper = _keeper;\n\n        // Emit event to signal a new strategy has been initialized.\n        emit NewTokenizedStrategy(address(this), _asset, API_VERSION);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints `shares` of strategy shares to `receiver` by\n     * depositing exactly `assets` of underlying tokens.\n     * @param assets The amount of underlying to deposit in.\n     * @param receiver The address to receive the `shares`.\n     * @return shares The actual amount of shares issued.\n     */\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) external nonReentrant returns (uint256 shares) {\n        // Checking max deposit will also check if shutdown.\n        require(\n            assets <= maxDeposit(receiver),\n            \"ERC4626: deposit more than max\"\n        );\n        // Check for rounding error.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        _deposit(receiver, assets, shares);\n    }\n\n    /**\n     * @notice Mints exactly `shares` of strategy shares to\n     * `receiver` by depositing `assets` of underlying tokens.\n     * @param shares The amount of strategy shares mint.\n     * @param receiver The address to receive the `shares`.\n     * @return assets The actual amount of asset deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) external nonReentrant returns (uint256 assets) {\n        // Checking max mint will also check if shutdown.\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n        // Check for rounding error.\n        require((assets = previewMint(shares)) != 0, \"ZERO_ASSETS\");\n\n        _deposit(receiver, assets, shares);\n    }\n\n    /**\n     * @notice Withdraws exactly `assets` from `owners` shares and sends\n     * the underlying tokens to `receiver`.\n     * @dev This will default to not allowing any loss to be taken.\n     * @param assets The amount of underlying to withdraw.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @return shares The actual amount of shares burnt.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares) {\n        return withdraw(assets, receiver, owner, 0);\n    }\n\n    /**\n     * @notice Withdraws `assets` from `owners` shares and sends\n     * the underlying tokens to `receiver`.\n     * @dev This includes an added parameter to allow for losses.\n     * @param assets The amount of underlying to withdraw.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @param maxLoss The amount of acceptable loss in Basis points.\n     * @return shares The actual amount of shares burnt.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxLoss\n    ) public nonReentrant returns (uint256 shares) {\n        require(\n            assets <= maxWithdraw(owner),\n            \"ERC4626: withdraw more than max\"\n        );\n        // Check for rounding error or 0 value.\n        require((shares = previewWithdraw(assets)) != 0, \"ZERO_SHARES\");\n\n        // Withdraw and track the actual amount withdrawn for loss check.\n        _withdraw(receiver, owner, assets, shares, maxLoss);\n    }\n\n    /**\n     * @notice Redeems exactly `shares` from `owner` and\n     * sends `assets` of underlying tokens to `receiver`.\n     * @dev This will default to allowing any loss passed to be realized.\n     * @param shares The amount of shares burnt.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @return assets The actual amount of underlying withdrawn.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256) {\n        // We default to not limiting a potential loss.\n        return redeem(shares, receiver, owner, MAX_BPS);\n    }\n\n    /**\n     * @notice Redeems exactly `shares` from `owner` and\n     * sends `assets` of underlying tokens to `receiver`.\n     * @dev This includes an added parameter to allow for losses.\n     * @param shares The amount of shares burnt.\n     * @param receiver The address to receive `assets`.\n     * @param owner The address whose shares are burnt.\n     * @param maxLoss The amount of acceptable loss in Basis points.\n     * @return . The actual amount of underlying withdrawn.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 maxLoss\n    ) public nonReentrant returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n        uint256 assets;\n        // Check for rounding error or 0 value.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        // We need to return the actual amount withdrawn in case of a loss.\n        return _withdraw(receiver, owner, assets, shares, maxLoss);\n    }\n\n    /**\n     * @notice The amount of shares that the strategy would\n     *  exchange for the amount of assets provided, in an\n     * ideal scenario where all the conditions are met.\n     *\n     * @param assets The amount of underlying.\n     * @return . Expected shares that `assets` represents.\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        // Saves an extra SLOAD if totalAssets() is non-zero.\n        uint256 _totalAssets = totalAssets();\n        uint256 _totalSupply = totalSupply();\n\n        // If assets are 0 but supply is not PPS = 0.\n        if (_totalAssets == 0) return _totalSupply == 0 ? assets : 0;\n\n        return assets.mulDiv(_totalSupply, _totalAssets, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice The amount of assets that the strategy would\n     * exchange for the amount of shares provided, in an\n     * ideal scenario where all the conditions are met.\n     *\n     * @param shares The amount of the strategies shares.\n     * @return . Expected amount of `asset` the shares represents.\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        // Saves an extra SLOAD if totalSupply() is non-zero.\n        uint256 supply = totalSupply();\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     * @dev This will round down.\n     *\n     * @param assets The amount of `asset` to deposits.\n     * @return . Expected shares that would be issued.\n     */\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their mint at the current block, given\n     * current on-chain conditions.\n     * @dev This is used instead of convertToAssets so that it can\n     * round up for safer mints.\n     *\n     * @param shares The amount of shares to mint.\n     * @return . The needed amount of `asset` for the mint.\n     */\n    function previewMint(uint256 shares) public view returns (uint256) {\n        // Saves an extra SLOAD if totalSupply() is non-zero.\n        uint256 supply = totalSupply();\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Up);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     * @dev This is used instead of convertToShares so that it can\n     * round up for safer withdraws.\n     *\n     * @param assets The amount of `asset` that would be withdrawn.\n     * @return . The amount of shares that would be burnt.\n     */\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        // Saves an extra SLOAD if totalAssets() is non-zero.\n        uint256 _totalAssets = totalAssets();\n        uint256 _totalSupply = totalSupply();\n\n        // If assets are 0 but supply is not, then PPS = 0.\n        if (_totalAssets == 0) return _totalSupply == 0 ? assets : 0;\n\n        return assets.mulDiv(_totalSupply, _totalAssets, Math.Rounding.Up);\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     * @dev This will round down.\n     *\n     * @param shares The amount of shares that would be redeemed.\n     * @return . The amount of `asset` that would be returned.\n     */\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /**\n     * @notice Total number of underlying assets that can\n     * be deposited by `_owner` into the strategy, where `owner`\n     * corresponds to the receiver of a {deposit} call.\n     *\n     * @param owner The address depositing.\n     * @return . The max that `owner` can deposit in `asset`.\n     */\n    function maxDeposit(address owner) public view returns (uint256) {\n        if (_strategyStorage().shutdown) return 0;\n\n        return IBaseStrategy(address(this)).availableDepositLimit(owner);\n    }\n\n    /**\n     * @notice Total number of shares that can be minted by `owner`\n     * into the strategy, where `_owner` corresponds to the receiver\n     * of a {mint} call.\n     *\n     * @param owner The address minting.\n     * @return _maxMint The max that `owner` can mint in shares.\n     */\n    function maxMint(address owner) public view returns (uint256 _maxMint) {\n        if (_strategyStorage().shutdown) return 0;\n\n        _maxMint = IBaseStrategy(address(this)).availableDepositLimit(owner);\n        if (_maxMint != type(uint256).max) {\n            _maxMint = convertToShares(_maxMint);\n        }\n    }\n\n    /**\n     * @notice Total number of underlying assets that can be\n     * withdrawn from the strategy by `owner`, where `owner`\n     * corresponds to the msg.sender of a {redeem} call.\n     *\n     * @param owner The owner of the shares.\n     * @return _maxWithdraw Max amount of `asset` that can be withdrawn.\n     */\n    function maxWithdraw(\n        address owner\n    ) public view returns (uint256 _maxWithdraw) {\n        _maxWithdraw = IBaseStrategy(address(this)).availableWithdrawLimit(\n            owner\n        );\n        if (_maxWithdraw == type(uint256).max) {\n            // Saves a min check if there is no withdrawal limit.\n            _maxWithdraw = convertToAssets(balanceOf(owner));\n        } else {\n            _maxWithdraw = Math.min(\n                convertToAssets(balanceOf(owner)),\n                _maxWithdraw\n            );\n        }\n    }\n\n    /**\n     * @notice Total number of strategy shares that can be\n     * redeemed from the strategy by `owner`, where `owner`\n     * corresponds to the msg.sender of a {redeem} call.\n     *\n     * @param owner The owner of the shares.\n     * @return _maxRedeem Max amount of shares that can be redeemed.\n     */\n    function maxRedeem(address owner) public view returns (uint256 _maxRedeem) {\n        _maxRedeem = IBaseStrategy(address(this)).availableWithdrawLimit(owner);\n        // Conversion would overflow and saves a min check if there is no withdrawal limit.\n        if (_maxRedeem == type(uint256).max) {\n            _maxRedeem = balanceOf(owner);\n        } else {\n            _maxRedeem = Math.min(\n                // Use preview withdraw to round up\n                previewWithdraw(_maxRedeem),\n                balanceOf(owner)\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the total amount of assets this strategy holds\n     * as of the last report.\n     *\n     * We manually track debt and idle to avoid any PPS manipulation\n     * from donations, touch values of debt etc.\n     *\n     * @return . Total assets the strategy holds.\n     */\n    function totalAssets() public view returns (uint256) {\n        StrategyData storage S = _strategyStorage();\n        unchecked {\n            return S.totalIdle + S.totalDebt;\n        }\n    }\n\n    /**\n     * @notice Get the current supply of the strategies shares.\n     *\n     * Locked shares issued to the strategy from profits are not\n     * counted towards the full supply until they are unlocked.\n     *\n     * As more shares slowly unlock the totalSupply will decrease\n     * causing the PPS of the strategy to increase.\n     *\n     * @return . Total amount of shares issued.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _strategyStorage().totalSupply - _unlockedShares();\n    }\n\n    /**\n     * @dev Function to be called during {deposit} and {mint}.\n     *\n     * This function handles all logic including transfers,\n     * minting and accounting.\n     *\n     * We do all external calls before updating any internal\n     * values to prevent view reentrancy issues from the token\n     * transfers or the _deployFunds() calls.\n     */\n    function _deposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) private {\n        require(receiver != address(this), \"ERC4626: mint to self\");\n\n        // Cache storage variables used more than once.\n        StrategyData storage S = _strategyStorage();\n        ERC20 _asset = S.asset;\n\n        // Need to transfer before minting or ERC777s could reenter.\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        // We will deposit up to current idle plus the new amount added\n        uint256 toDeploy = S.totalIdle + assets;\n\n        // Cache for post {deployFunds} checks.\n        uint256 beforeBalance = _asset.balanceOf(address(this));\n\n        // Deploy up to all loose funds.\n        IBaseStrategy(address(this)).deployFunds(toDeploy);\n\n        // Always get the actual amount deployed. We double check the\n        // diff against toDeploy for complete accuracy.\n        uint256 deployed = Math.min(\n            beforeBalance - _asset.balanceOf(address(this)),\n            toDeploy\n        );\n\n        // Adjust total Assets.\n        S.totalDebt += deployed;\n        unchecked {\n            // Cant't underflow due to previous min check.\n            S.totalIdle = toDeploy - deployed;\n        }\n\n        // mint shares\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /**\n     * @dev To be called during {redeem} and {withdraw}.\n     *\n     * This will handle all logic, transfers and accounting\n     * in order to service the withdraw request.\n     *\n     * If we are not able to withdraw the full amount needed, it will\n     * be counted as a loss and passed on to the user.\n     */\n    function _withdraw(\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares,\n        uint256 maxLoss\n    ) private returns (uint256) {\n        require(receiver != address(0), \"ZERO ADDRESS\");\n        require(maxLoss <= MAX_BPS, \"exceeds MAX_BPS\");\n\n        // Spend allowance if applicable.\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        StrategyData storage S = _strategyStorage();\n        // Expected behavior is to need to free funds so we cache `_asset`.\n        ERC20 _asset = S.asset;\n\n        uint256 idle = S.totalIdle;\n\n        // Check if we need to withdraw funds.\n        if (idle < assets) {\n            // Cache before balance for diff checks.\n            uint256 before = _asset.balanceOf(address(this));\n\n            // Tell Strategy to free what we need.\n            unchecked {\n                IBaseStrategy(address(this)).freeFunds(assets - idle);\n            }\n\n            // Return the actual amount withdrawn. Adjust for potential over withdraws.\n            uint256 withdrawn = Math.min(\n                _asset.balanceOf(address(this)) - before,\n                S.totalDebt\n            );\n\n            unchecked {\n                idle += withdrawn;\n            }\n\n            uint256 loss;\n            // If we didn't get enough out then we have a loss.\n            if (idle < assets) {\n                unchecked {\n                    loss = assets - idle;\n                }\n                // If a non-default max loss parameter was set.\n                if (maxLoss < MAX_BPS) {\n                    // Make sure we are within the acceptable range.\n                    require(\n                        loss <= (assets * maxLoss) / MAX_BPS,\n                        \"too much loss\"\n                    );\n                }\n                // Lower the amount to be withdrawn.\n                assets = idle;\n            }\n\n            // Update debt storage.\n            S.totalDebt -= (withdrawn + loss);\n        }\n\n        // Update idle based on how much we took.\n        S.totalIdle = idle - assets;\n\n        _burn(owner, shares);\n\n        _asset.safeTransfer(receiver, assets);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // Return the actual amount of assets withdrawn.\n        return assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        PROFIT LOCKING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function for keepers to call to harvest and record all\n     * profits accrued.\n     *\n     * @dev This should be called through protected relays if swaps\n     * are likely occur.\n     *\n     * This will account for any gains/losses since the last report\n     * and charge fees accordingly.\n     *\n     * Any profit over the fees charged will be immediately locked\n     * so there is no change in PricePerShare. Then slowly unlocked\n     * over the `maxProfitUnlockTime` each second based on the\n     * calculated `profitUnlockingRate`.\n     *\n     * In case of a loss it will first attempt to offset the loss\n     * with any remaining locked shares from the last report in\n     * order to reduce any negative impact to PPS.\n     *\n     * Will then recalculate the new time to unlock profits over and the\n     * rate based on a weighted average of any remaining time from the\n     * last report and the new amount of shares to be locked.\n     *\n     * @return profit The notional amount of gain if any since the last\n     * report in terms of `asset`.\n     * @return loss The notional amount of loss if any since the last\n     * report in terms of `asset`.\n     */\n    function report()\n        external\n        nonReentrant\n        onlyKeepers\n        returns (uint256 profit, uint256 loss)\n    {\n        // Cache storage pointer since its used repeatedly.\n        StrategyData storage S = _strategyStorage();\n\n        uint256 oldTotalAssets;\n        unchecked {\n            // Manually calculate totalAssets to save a SLOAD.\n            oldTotalAssets = S.totalIdle + S.totalDebt;\n        }\n\n        // Tell the strategy to report the real total assets it has.\n        // It should do all reward selling and redepositing now and\n        // account for deployed and loose `asset` so we can accurately\n        // account for all funds including those potentially airdropped\n        // by a trade factory. It is safe here to use asset.balanceOf()\n        // instead of totalIdle because any profits are immediately locked.\n        uint256 newTotalAssets = IBaseStrategy(address(this))\n            .harvestAndReport();\n\n        // Burn unlocked shares.\n        _burnUnlockedShares();\n\n        // Initialize variables needed throughout.\n        uint256 totalFees;\n        uint256 protocolFees;\n        uint256 sharesToLock;\n        uint256 _profitMaxUnlockTime = S.profitMaxUnlockTime;\n        // Calculate profit/loss.\n        if (newTotalAssets > oldTotalAssets) {\n            // We have a profit.\n            unchecked {\n                profit = newTotalAssets - oldTotalAssets;\n                // Asses performance fees.\n                totalFees = (profit * S.performanceFee) / MAX_BPS;\n            }\n\n            address protocolFeesRecipient;\n            uint256 performanceFeeShares;\n            uint256 protocolFeeShares;\n            // If performance fees are 0 so will protocol fees.\n            if (totalFees != 0) {\n                // Get the config from the factory.\n                uint16 protocolFeeBps;\n                (protocolFeeBps, protocolFeesRecipient) = IFactory(FACTORY)\n                    .protocolFeeConfig();\n\n                // Check if there is a protocol fee to charge.\n                if (protocolFeeBps != 0) {\n                    // Calculate protocol fees based on the performance Fees.\n                    protocolFees = (totalFees * protocolFeeBps) / MAX_BPS;\n                }\n\n                // We need to get the shares to issue for the fees at\n                // current PPS before any minting or burning.\n                unchecked {\n                    performanceFeeShares = convertToShares(\n                        totalFees - protocolFees\n                    );\n                }\n                if (protocolFees != 0) {\n                    protocolFeeShares = convertToShares(protocolFees);\n                }\n            }\n\n            // we have a net profit. Check if we are locking profit.\n            if (_profitMaxUnlockTime != 0) {\n                // lock (profit - fees)\n                unchecked {\n                    sharesToLock = convertToShares(profit - totalFees);\n                }\n                // Mint the shares to lock the strategy.\n                _mint(address(this), sharesToLock);\n            }\n\n            // Mint fees shares to recipients.\n            if (performanceFeeShares != 0) {\n                _mint(S.performanceFeeRecipient, performanceFeeShares);\n            }\n\n            if (protocolFeeShares != 0) {\n                _mint(protocolFeesRecipient, protocolFeeShares);\n            }\n        } else {\n            // We have a loss.\n            unchecked {\n                loss = oldTotalAssets - newTotalAssets;\n            }\n\n            // Check in case else was due to being equal.\n            if (loss != 0) {\n                // We will try and burn shares from any pending profit still unlocking\n                // to offset the loss to prevent any PPS decline post report.\n                uint256 sharesToBurn = Math.min(\n                    S.balances[address(this)],\n                    convertToShares(loss)\n                );\n\n                // Check if there is anything to burn.\n                if (sharesToBurn != 0) {\n                    _burn(address(this), sharesToBurn);\n                }\n            }\n        }\n\n        // Update unlocking rate and time to fully unlocked.\n        uint256 totalLockedShares = S.balances[address(this)];\n        if (totalLockedShares != 0) {\n            uint256 previouslyLockedTime;\n            uint128 _fullProfitUnlockDate = S.fullProfitUnlockDate;\n            // Check if we need to account for shares still unlocking.\n            if (_fullProfitUnlockDate > block.timestamp) {\n                unchecked {\n                    // There will only be previously locked shares if time remains.\n                    // We calculate this here since it should be rare.\n                    previouslyLockedTime =\n                        (_fullProfitUnlockDate - block.timestamp) *\n                        (totalLockedShares - sharesToLock);\n                }\n            }\n\n            // newProfitLockingPeriod is a weighted average between the remaining\n            // time of the previously locked shares and the profitMaxUnlockTime.\n            uint256 newProfitLockingPeriod = (previouslyLockedTime +\n                sharesToLock *\n                _profitMaxUnlockTime) / totalLockedShares;\n\n            // Calculate how many shares unlock per second.\n            S.profitUnlockingRate =\n                (totalLockedShares * MAX_BPS_EXTENDED) /\n                newProfitLockingPeriod;\n\n            // Calculate how long until the full amount of shares is unlocked.\n            S.fullProfitUnlockDate = uint128(\n                block.timestamp + newProfitLockingPeriod\n            );\n        } else {\n            // Only setting this to 0 will turn in the desired effect,\n            // no need to update fullProfitUnlockDate.\n            S.profitUnlockingRate = 0;\n        }\n\n        // Update storage we use the actual loose here since it should have\n        // been accounted for in `harvestAndReport` and any airdropped amounts\n        // would have been locked to prevent PPS manipulation.\n        uint256 newIdle = S.asset.balanceOf(address(this));\n        S.totalIdle = newIdle;\n        S.totalDebt = newTotalAssets - newIdle;\n\n        S.lastReport = uint128(block.timestamp);\n\n        // Emit event with info\n        emit Reported(\n            profit,\n            loss,\n            protocolFees, // Protocol fees\n            totalFees - protocolFees // Performance Fees\n        );\n    }\n\n    /**\n     * @dev Called during reports to burn shares that have been unlocked\n     * since the last report.\n     *\n     * Will reset the `lastReport` if haven't unlocked the full amount yet\n     * so future calculations remain correct.\n     */\n    function _burnUnlockedShares() private {\n        uint256 unlocked = _unlockedShares();\n        if (unlocked == 0) {\n            return;\n        }\n\n        // update variables (done here to keep _unlockedShares() as a view function)\n        if (_strategyStorage().fullProfitUnlockDate > block.timestamp) {\n            _strategyStorage().lastReport = uint128(block.timestamp);\n        }\n\n        _burn(address(this), unlocked);\n    }\n\n    /**\n     * @notice Get how many shares have been unlocked since last report.\n     * @return . The amount of shares that have unlocked.\n     */\n    function unlockedShares() external view returns (uint256) {\n        return _unlockedShares();\n    }\n\n    /**\n     * @dev To determine how many of the shares that were locked during the last\n     * report have since unlocked.\n     *\n     * If the `fullProfitUnlockDate` has passed the full strategy's balance will\n     * count as unlocked.\n     *\n     * @return unlocked The amount of shares that have unlocked.\n     */\n    function _unlockedShares() private view returns (uint256 unlocked) {\n        // should save 2 extra calls for most scenarios.\n        StrategyData storage S = _strategyStorage();\n        uint128 _fullProfitUnlockDate = S.fullProfitUnlockDate;\n        if (_fullProfitUnlockDate > block.timestamp) {\n            unchecked {\n                unlocked =\n                    (S.profitUnlockingRate * (block.timestamp - S.lastReport)) /\n                    MAX_BPS_EXTENDED;\n            }\n        } else if (_fullProfitUnlockDate != 0) {\n            // All shares have been unlocked.\n            unlocked = S.balances[address(this)];\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        TENDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice For a 'keeper' to 'tend' the strategy if a custom\n     * tendTrigger() is implemented.\n     *\n     * @dev Both 'tendTrigger' and '_tend' will need to be overridden\n     * for this to be used.\n     *\n     * This will callback the internal '_tend' call in the BaseStrategy\n     * with the total current amount available to the strategy to deploy.\n     *\n     * Keepers are expected to use protected relays in tend calls so this\n     * can be used for illiquid or manipulatable strategies to compound\n     * rewards, perform maintenance or deposit/withdraw funds.\n     *\n     * All accounting for totalDebt and totalIdle updates will be done\n     * here post '_tend'.\n     *\n     * This should never cause an increase in PPS. Total assets should\n     * be the same before and after\n     *\n     * A report() call will be needed to record the profit.\n     */\n    function tend() external nonReentrant onlyKeepers {\n        // Tend the strategy with the current totalIdle.\n        IBaseStrategy(address(this)).tendThis(_strategyStorage().totalIdle);\n\n        // Update balances based on ending state.\n        _updateBalances();\n    }\n\n    /**\n     * @notice Update the internal balances that make up `totalAssets`.\n     * @dev This will update the ratio of debt and idle that make up\n     * totalAssets based on the actual current loose amount of `asset`\n     * in a safe way. But will keep `totalAssets` the same, thus having\n     * no effect on Price Per Share.\n     */\n    function _updateBalances() internal {\n        StrategyData storage S = _strategyStorage();\n\n        // Get the current loose balance.\n        uint256 assetBalance = S.asset.balanceOf(address(this));\n\n        // If its already accurate do nothing.\n        if (S.totalIdle == assetBalance) return;\n\n        // Get the total assets the strategy should have.\n        uint256 _totalAssets = totalAssets();\n\n        // If we have enough loose to cover all assets.\n        if (assetBalance >= _totalAssets) {\n            // Set idle to totalAssets.\n            S.totalIdle = _totalAssets;\n            // Set debt to 0.\n            S.totalDebt = 0;\n        } else {\n            // Otherwise idle is the actual loose balance.\n            S.totalIdle = assetBalance;\n            unchecked {\n                // And debt is the difference.\n                S.totalDebt = _totalAssets - assetBalance;\n            }\n        }\n\n        // Enforce the invariant.\n        require(_totalAssets == totalAssets(), \"!totalAssets\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        STRATEGY SHUTDOWN\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Used to shutdown the strategy preventing any further deposits.\n     * @dev Can only be called by the current `management` or `emergencyAdmin`.\n     *\n     * This will stop any new {deposit} or {mint} calls but will\n     * not prevent {withdraw} or {redeem}. It will also still allow for\n     * {tend} and {report} so that management can report any last losses\n     * in an emergency as well as provide any maintenance to allow for full\n     * withdraw.\n     *\n     * This is a one way switch and can never be set back once shutdown.\n     */\n    function shutdownStrategy() external onlyEmergencyAuthorized {\n        _strategyStorage().shutdown = true;\n\n        emit StrategyShutdown();\n    }\n\n    /**\n     * @notice To manually withdraw funds from the yield source after a\n     * strategy has been shutdown.\n     * @dev This can only be called post {shutdownStrategy}.\n     *\n     * This will update totalDebt and totalIdle based on the amount of\n     * loose `asset` after the withdraw leaving `totalAssets` unchanged.\n     *\n     * A strategist will need to override the {_emergencyWithdraw} function\n     * in their strategy for this to work.\n     *\n     * @param amount The amount of asset to attempt to free.\n     */\n    function emergencyWithdraw(\n        uint256 amount\n    ) external nonReentrant onlyEmergencyAuthorized {\n        // Make sure the strategy has been shutdown.\n        require(_strategyStorage().shutdown, \"not shutdown\");\n\n        // Withdraw from the yield source.\n        IBaseStrategy(address(this)).shutdownWithdraw(amount);\n\n        // Record the updated balances based on the new amounts.\n        _updateBalances();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GETTER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the underlying asset for the strategy.\n     * @return . The underlying asset.\n     */\n    function asset() external view returns (address) {\n        return address(_strategyStorage().asset);\n    }\n\n    /**\n     * @notice Get the API version for this TokenizedStrategy.\n     * @return . The API version for this TokenizedStrategy\n     */\n    function apiVersion() external pure returns (string memory) {\n        return API_VERSION;\n    }\n\n    /**\n     * @notice Get the current total idle for a strategy.\n     * @return . The current amount of idle funds.\n     */\n    function totalIdle() external view returns (uint256) {\n        return _strategyStorage().totalIdle;\n    }\n\n    /**\n     * @notice Get the current total debt for a strategy.\n     * @return . The current amount of debt.\n     */\n    function totalDebt() external view returns (uint256) {\n        return _strategyStorage().totalDebt;\n    }\n\n    /**\n     * @notice Get the current address that controls the strategy.\n     * @return . Address of management\n     */\n    function management() external view returns (address) {\n        return _strategyStorage().management;\n    }\n\n    /**\n     * @notice Get the current pending management address if any.\n     * @return . Address of pendingManagement\n     */\n    function pendingManagement() external view returns (address) {\n        return _strategyStorage().pendingManagement;\n    }\n\n    /**\n     * @notice Get the current address that can call tend and report.\n     * @return . Address of the keeper\n     */\n    function keeper() external view returns (address) {\n        return _strategyStorage().keeper;\n    }\n\n    /**\n     * @notice Get the current address that can shutdown and emergency withdraw.\n     * @return . Address of the emergencyAdmin\n     */\n    function emergencyAdmin() external view returns (address) {\n        return _strategyStorage().emergencyAdmin;\n    }\n\n    /**\n     * @notice Get the current performance fee charged on profits.\n     * denominated in Basis Points where 10_000 == 100%\n     * @return . Current performance fee.\n     */\n    function performanceFee() external view returns (uint16) {\n        return _strategyStorage().performanceFee;\n    }\n\n    /**\n     * @notice Get the current address that receives the performance fees.\n     * @return . Address of performanceFeeRecipient\n     */\n    function performanceFeeRecipient() external view returns (address) {\n        return _strategyStorage().performanceFeeRecipient;\n    }\n\n    /**\n     * @notice Gets the timestamp at which all profits will be unlocked.\n     * @return . The full profit unlocking timestamp\n     */\n    function fullProfitUnlockDate() external view returns (uint256) {\n        return uint256(_strategyStorage().fullProfitUnlockDate);\n    }\n\n    /**\n     * @notice The per second rate at which profits are unlocking.\n     * @dev This is denominated in EXTENDED_BPS decimals.\n     * @return . The current profit unlocking rate.\n     */\n    function profitUnlockingRate() external view returns (uint256) {\n        return _strategyStorage().profitUnlockingRate;\n    }\n\n    /**\n     * @notice Gets the current time profits are set to unlock over.\n     * @return . The current profit max unlock time.\n     */\n    function profitMaxUnlockTime() external view returns (uint256) {\n        return _strategyStorage().profitMaxUnlockTime;\n    }\n\n    /**\n     * @notice The timestamp of the last time protocol fees were charged.\n     * @return . The last report.\n     */\n    function lastReport() external view returns (uint256) {\n        return uint256(_strategyStorage().lastReport);\n    }\n\n    /**\n     * @notice Get the price per share.\n     * @dev This value offers limited precision. Integrations that require\n     * exact precision should use convertToAssets or convertToShares instead.\n     *\n     * @return . The price per share.\n     */\n    function pricePerShare() external view returns (uint256) {\n        return convertToAssets(10 ** _strategyStorage().decimals);\n    }\n\n    /**\n     * @notice To check if the strategy has been shutdown.\n     * @return . Whether or not the strategy is shutdown.\n     */\n    function isShutdown() public view returns (bool) {\n        return _strategyStorage().shutdown;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        SETTER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Step one of two to set a new address to be in charge of the strategy.\n     * @dev Can only be called by the current `management`. The address is\n     * set to pending management and will then have to call {acceptManagement}\n     * in order for the 'management' to officially change.\n     *\n     * Cannot set `management` to address(0).\n     *\n     * @param _management New address to set `pendingManagement` to.\n     */\n    function setPendingManagement(address _management) external onlyManagement {\n        require(_management != address(0), \"ZERO ADDRESS\");\n        _strategyStorage().pendingManagement = _management;\n\n        emit UpdatePendingManagement(_management);\n    }\n\n    /**\n     * @notice Step two of two to set a new 'management' of the strategy.\n     * @dev Can only be called by the current `pendingManagement`.\n     */\n    function acceptManagement() external {\n        require(msg.sender == _strategyStorage().pendingManagement, \"!pending\");\n        _strategyStorage().management = msg.sender;\n        _strategyStorage().pendingManagement = address(0);\n\n        emit UpdateManagement(msg.sender);\n    }\n\n    /**\n     * @notice Sets a new address to be in charge of tend and reports.\n     * @dev Can only be called by the current `management`.\n     *\n     * @param _keeper New address to set `keeper` to.\n     */\n    function setKeeper(address _keeper) external onlyManagement {\n        _strategyStorage().keeper = _keeper;\n\n        emit UpdateKeeper(_keeper);\n    }\n\n    /**\n     * @notice Sets a new address to be able to shutdown the strategy.\n     * @dev Can only be called by the current `management`.\n     *\n     * @param _emergencyAdmin New address to set `emergencyAdmin` to.\n     */\n    function setEmergencyAdmin(\n        address _emergencyAdmin\n    ) external onlyManagement {\n        _strategyStorage().emergencyAdmin = _emergencyAdmin;\n\n        emit UpdateEmergencyAdmin(_emergencyAdmin);\n    }\n\n    /**\n     * @notice Sets the performance fee to be charged on reported gains.\n     * @dev Can only be called by the current `management`.\n     *\n     * Denominated in Basis Points. So 100% == 10_000.\n     * Cannot be set less than the MIN_FEE.\n     * Cannot set greater than to MAX_FEE.\n     *\n     * @param _performanceFee New performance fee.\n     */\n    function setPerformanceFee(uint16 _performanceFee) external onlyManagement {\n        require(_performanceFee >= MIN_FEE, \"MIN FEE\");\n        require(_performanceFee <= MAX_FEE, \"MAX FEE\");\n        _strategyStorage().performanceFee = _performanceFee;\n\n        emit UpdatePerformanceFee(_performanceFee);\n    }\n\n    /**\n     * @notice Sets a new address to receive performance fees.\n     * @dev Can only be called by the current `management`.\n     *\n     * Cannot set to address(0).\n     *\n     * @param _performanceFeeRecipient New address to set `management` to.\n     */\n    function setPerformanceFeeRecipient(\n        address _performanceFeeRecipient\n    ) external onlyManagement {\n        require(_performanceFeeRecipient != address(0), \"ZERO ADDRESS\");\n        require(_performanceFeeRecipient != address(this), \"Cannot be self\");\n        _strategyStorage().performanceFeeRecipient = _performanceFeeRecipient;\n\n        emit UpdatePerformanceFeeRecipient(_performanceFeeRecipient);\n    }\n\n    /**\n     * @notice Sets the time for profits to be unlocked over.\n     * @dev Can only be called by the current `management`.\n     *\n     * Denominated in seconds and cannot be greater than 1 year.\n     *\n     * NOTE: Setting to 0 will cause all currently locked profit\n     * to be unlocked instantly and should be done with care.\n     *\n     * `profitMaxUnlockTime` is stored as a uint32 for packing but can\n     * be passed in as uint256 for simplicity.\n     *\n     * @param _profitMaxUnlockTime New `profitMaxUnlockTime`.\n     */\n    function setProfitMaxUnlockTime(\n        uint256 _profitMaxUnlockTime\n    ) external onlyManagement {\n        // Must be less than a year.\n        require(_profitMaxUnlockTime <= SECONDS_PER_YEAR, \"too long\");\n        StrategyData storage S = _strategyStorage();\n\n        // If we are setting to 0 we need to adjust amounts.\n        if (_profitMaxUnlockTime == 0) {\n            // Burn all shares if applicable.\n            _burn(address(this), S.balances[address(this)]);\n            // Reset unlocking variables\n            S.profitUnlockingRate = 0;\n            S.fullProfitUnlockDate = 0;\n        }\n\n        S.profitMaxUnlockTime = uint32(_profitMaxUnlockTime);\n\n        emit UpdateProfitMaxUnlockTime(_profitMaxUnlockTime);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC20 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the name of the token.\n     * @return . The name the strategy is using for its token.\n     */\n    function name() external view returns (string memory) {\n        return _strategyStorage().name;\n    }\n\n    /**\n     * @notice Returns the symbol of the strategies token.\n     * @dev Will be 'ys + asset symbol'.\n     * @return . The symbol the strategy is using for its tokens.\n     */\n    function symbol() public view returns (string memory) {\n        return\n            string(abi.encodePacked(\"ys\", _strategyStorage().asset.symbol()));\n    }\n\n    /**\n     * @notice Returns the number of decimals used to get its user representation.\n     * @return . The decimals used for the strategy and `asset`.\n     */\n    function decimals() public view returns (uint8) {\n        return _strategyStorage().decimals;\n    }\n\n    /**\n     * @notice Returns the current balance for a given '_account'.\n     * @dev If the '_account` is the strategy then this will subtract\n     * the amount of shares that have been unlocked since the last profit first.\n     * @param account the address to return the balance for.\n     * @return . The current balance in y shares of the '_account'.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        if (account == address(this)) {\n            return _strategyStorage().balances[account] - _unlockedShares();\n        }\n        return _strategyStorage().balances[account];\n    }\n\n    /**\n     * @notice Transfer '_amount` of shares from `msg.sender` to `to`.\n     * @dev\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `to` cannot be the address of the strategy.\n     * - the caller must have a balance of at least `_amount`.\n     *\n     * @param to The address shares will be transferred to.\n     * @param amount The amount of shares to be transferred from sender.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     * @param owner The address who owns the shares.\n     * @param spender The address who would be moving the owners shares.\n     * @return . The remaining amount of shares of `owner` that could be moved by `spender`.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) public view returns (uint256) {\n        return _strategyStorage().allowances[owner][spender];\n    }\n\n    /**\n     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n     * @dev\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     *\n     * @param spender the address to allow the shares to be moved by.\n     * @param amount the amount of shares to allow `spender` to move.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * @dev\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `to` cannot be the address of the strategy.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     *\n     * Emits a {Transfer} event.\n     *\n     * @param from the address to be moving shares from.\n     * @param to the address to be moving shares to.\n     * @param amount the quantity of shares to move.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - cannot give spender over uint256.max allowance\n     *\n     * @param spender the account that will be able to move the senders shares.\n     * @param addedValue the extra amount to add to the current allowance.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     *\n     * @param spender the account that will be able to move less of the senders shares.\n     * @param subtractedValue the amount to decrease the current allowance by.\n     * @return . a boolean value indicating whether the operation succeeded.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, allowance(owner, spender) - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `to` cannot be the strategies address\n     * - `from` must have a balance of at least `amount`.\n     *\n     */\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(to != address(this), \"ERC20 transfer to strategy\");\n        StrategyData storage S = _strategyStorage();\n\n        S.balances[from] -= amount;\n        unchecked {\n            S.balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     *\n     */\n    function _mint(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        StrategyData storage S = _strategyStorage();\n\n        S.totalSupply += amount;\n        unchecked {\n            S.balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        StrategyData storage S = _strategyStorage();\n\n        S.balances[account] -= amount;\n        unchecked {\n            S.totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _strategyStorage().allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * @dev Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * @param _owner the address of the account to return the nonce for.\n     * @return . the current nonce for the account.\n     */\n    function nonces(address _owner) external view returns (uint256) {\n        return _strategyStorage().nonces[_owner];\n    }\n\n    /**\n     * @notice Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * @dev IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"ERC20: PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                _strategyStorage().nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"ERC20: INVALID_SIGNER\"\n            );\n\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    /**\n     * @notice Returns the domain separator used in the encoding of the signature\n     * for {permit}, as defined by {EIP712}.\n     *\n     * @dev This checks that the current chain id is the same as when the contract\n     * was deployed to prevent replay attacks. If false it will calculate a new\n     * domain separator based on the new chain id.\n     *\n     * @return . The domain separator that will be used for any {permit} calls.\n     */\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        StrategyData storage S = _strategyStorage();\n        return\n            block.chainid == S.INITIAL_CHAIN_ID\n                ? S.INITIAL_DOMAIN_SEPARATOR\n                : _computeDomainSeparator();\n    }\n\n    /**\n     * @dev Calculates and returns the domain separator to be used in any\n     * permit functions for the strategies {permit} calls.\n     *\n     * This will be used at the initialization of each new strategies storage.\n     * It would then be used in the future in the case of any forks in which\n     * the current chain id is not the same as the original.\n     *\n     */\n    function _computeDomainSeparator() private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(_strategyStorage().name)),\n                    keccak256(bytes(API_VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DEPLOYMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev On contract creation we set `asset` for this contract to address(1).\n     * This prevents it from ever being initialized in the future.\n     */\n    constructor() {\n        _strategyStorage().asset = ERC20(address(1));\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}